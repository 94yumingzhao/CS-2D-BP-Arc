# Arc分支约束未生效问题修复

**日期**: 2025-12-29
**项目**: CS-2D-BP-Arc
**问题级别**: 严重 (导致算法完全失效)

---

## 问题现象

在分支定价(Branch and Price)过程中，观察到以下异常：

```
[00:05.5] BP   | n=1   LB=21.50  UB=--   Gap=--     act=1  cut=0
[00:06.1] BP   | n=3   LB=21.50  UB=--   Gap=--     act=2  cut=0
[00:06.9] BP   | n=5   LB=21.50  UB=--   Gap=--     act=3  cut=0
...
[00:40.5] BP   | n=97  LB=21.50  UB=--   Gap=--     act=49 cut=0
```

**异常特征**:
1. `UB=--` 始终无值 - 从未找到整数解
2. `Gap=--` 无法计算 - 因为没有上界
3. `cut=0` 始终为0 - 没有任何节点被剪枝
4. `act` 持续增长 - 分支树无限膨胀
5. `LB` 保持不变 - 所有子节点下界与根节点相同

**预期行为**:
- 随着分支深入，应该逐步找到整数解
- UB应该有值，Gap应该逐步缩小
- 应该有节点被剪枝

---

## 问题分析

### 分支定价算法回顾

分支定价 = 列生成 + 分支定界

1. **列生成**: 在每个节点求解LP松弛，通过子问题生成新列
2. **分支**: 对分数解进行分支，创建子节点
3. **定界**: 通过下界剪枝不可能产生更优解的节点

### Arc分支策略

本项目使用Arc流量分支策略：
- 将LP解转换为Arc流量
- 对分数流量的Arc进行分支
- 左分支: Arc流量 <= floor(流量)
- 右分支: Arc流量 >= ceil(流量)

### 代码追踪

#### 1. 分支创建 (branch_and_price.cpp)

```cpp
void CreateLeftChild(BPNode* parent, int new_id, BPNode* child) {
    // 继承父节点的Arc约束
    child->sp1_zero_arcs_ = parent->sp1_zero_arcs_;
    child->sp1_lower_arcs_ = parent->sp1_lower_arcs_;
    // ...

    // 添加新的分支约束
    if (parent->branch_type_ == kBranchSP1Arc) {
        int bound = static_cast<int>(floor(parent->branch_arc_flow_));
        if (bound == 0) {
            child->sp1_zero_arcs_.insert(parent->branch_arc_);  // 禁用Arc
        } else {
            child->sp1_lower_arcs_.push_back(parent->branch_arc_);
            child->sp1_lower_bounds_.push_back(bound);  // Arc <= bound
        }
    }
}
```

分支约束被正确创建并存储在节点中。

#### 2. 子问题方法配置 (main.cpp)

```cpp
// 配置子问题求解方法
params.sp1_method_ = kCplexIP;  // <-- 问题所在!
params.sp2_method_ = kCplexIP;
```

#### 3. 子问题方法分发 (column_generation.cpp)

```cpp
bool SolveNodeSP1(ProblemParams& params, ProblemData& data, BPNode* node) {
    int method = node->sp1_method_;

    switch (method) {
        case kArcFlow:
            // Arc Flow: 在函数内部应用sp1_*_arcs_约束
            return SolveNodeSP1ArcFlow(params, data, node);
        case kDP:
            // DP不支持Arc约束, 可能导致分支无效
            return SolveNodeSP1DP(params, data, node);
        case kCplexIP:
        default:
            // CPLEX背包不包含Arc约束  <-- 这里!
            return SolveNodeSP1Knapsack(params, data, node);
    }
}
```

#### 4. 背包方法 (new_node_sub.cpp)

```cpp
bool SolveNodeSP1Knapsack(ProblemParams& params, ProblemData& data, BPNode* node) {
    // 构建背包模型
    // max sum(v_j * G_j) s.t. sum(w_j * G_j) <= W

    // 注意: 这里完全没有使用node->sp1_zero_arcs_等约束!
    // 分支约束被忽略
}
```

#### 5. Arc Flow方法 (new_node_sub.cpp)

```cpp
bool SolveNodeSP1ArcFlow(ProblemParams& params, ProblemData& data, BPNode* node) {
    // ...

    // 添加从父节点继承的SP1 Arc约束
    // 禁用Arc约束: 设置上界为0
    for (const auto& arc : node->sp1_zero_arcs_) {
        if (arc_data.arc_to_index_.count(arc)) {
            int idx = arc_data.arc_to_index_.at(arc);
            vars[idx].setUB(0);  // 正确应用约束!
        }
    }

    // Arc上界约束
    for (size_t i = 0; i < node->sp1_lower_arcs_.size(); i++) {
        // ...
        vars[idx].setUB(node->sp1_lower_bounds_[i]);  // 正确应用约束!
    }

    // Arc下界约束
    for (size_t i = 0; i < node->sp1_greater_arcs_.size(); i++) {
        // ...
        vars[idx].setLB(node->sp1_greater_bounds_[i]);  // 正确应用约束!
    }
}
```

---

## 根本原因

```
                    分支定价主循环
                         |
                         v
              +----------+----------+
              |                     |
         SelectBranchArc       SolveNodeCG
              |                     |
              v                     v
    创建Arc分支约束            求解子问题
    (存入sp1_zero_arcs_等)          |
                                    v
                           SolveNodeSP1/SP2
                                    |
                         +----------+----------+
                         |          |          |
                    kArcFlow    kCplexIP     kDP
                         |          |          |
                         v          v          v
                    应用约束    忽略约束    忽略约束
                         |          |          |
                         v          v          v
                      有效分支   无效分支   无效分支
```

**问题**: `main.cpp`中配置使用`kCplexIP`方法，但该方法不支持Arc约束。

**结果**:
- 分支约束被创建但从未被应用
- 子问题求解忽略分支约束
- 所有子节点的解空间与父节点相同
- 分支完全无效，永远找不到整数解

---

## 解决方案

### 修改 main.cpp

```cpp
// 修改前
params.sp1_method_ = kCplexIP;
params.sp2_method_ = kCplexIP;

// 修改后
// 注意: 必须使用kArcFlow以支持Arc分支约束, kCplexIP不支持Arc约束!
params.sp1_method_ = kArcFlow;
params.sp2_method_ = kArcFlow;
```

### 方法对比

| 方法 | Arc约束支持 | 性能 | 适用场景 |
|------|------------|------|----------|
| kCplexIP | 不支持 | 中等 | 仅根节点或无分支 |
| kArcFlow | 支持 | 较慢 | 分支定价必需 |
| kDP | 不支持 | 最快 | 仅根节点或无分支 |

---

## 验证

修复后预期行为：

```
[00:05.5] BP   | n=1   LB=21.50  UB=--   Gap=--     act=1  cut=0
[00:08.2] BP   | n=9   LB=21.50  UB=24   Gap=10.4%  act=4  cut=3   <- 找到整数解
[00:12.1] BP   | n=21  LB=21.50  UB=23   Gap=6.5%   act=6  cut=8   <- 改进上界
[00:18.5] BP   | n=35  LB=22.00  UB=23   Gap=4.3%   act=3  cut=15  <- 剪枝增加
[00:25.0] 完成 | 最优=22 Gap=0.0% nodes=42                         <- 找到最优
```

---

## 经验教训

### 1. 方法与策略的一致性

分支策略必须与子问题求解方法匹配：
- Arc分支策略 -> 必须使用Arc Flow子问题方法
- 变量分支策略 -> 可以使用任何子问题方法

### 2. 代码注释的重要性

column_generation.cpp中已有注释说明：
```cpp
case kCplexIP:
default:
    // CPLEX背包不包含Arc约束
    return SolveNodeSP1Knapsack(params, data, node);
```

但main.cpp中没有相应警告，导致配置错误。

### 3. 输出监控的价值

通过观察`UB=--`和`cut=0`的异常模式，能够快速定位到"分支无效"的问题。

### 4. 建议的改进

1. **强制检查**: 在RunBranchAndPrice开始时检查method配置
   ```cpp
   if (params.sp1_method_ != kArcFlow || params.sp2_method_ != kArcFlow) {
       LOG("[警告] Arc分支策略需要kArcFlow方法, 当前配置可能导致分支无效");
   }
   ```

2. **配置说明**: 在main.cpp中添加更明确的注释

3. **测试用例**: 添加验证分支有效性的测试

---

## 相关文件

- `src/main.cpp` - 子问题方法配置
- `src/column_generation.cpp` - 方法分发逻辑
- `src/new_node_sub.cpp` - 子问题求解实现
- `src/branch_and_price.cpp` - 分支约束创建

---

**文档编写**: Claude Code
**验证平台**: Windows WSL2 + MSVC 2022 + CPLEX 22.1.0
