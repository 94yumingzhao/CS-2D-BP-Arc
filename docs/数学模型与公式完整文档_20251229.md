# CS-2D-BP-Arc 数学模型与公式完整文档

**项目**: CS-2D-BP-Arc (二维下料问题分支定价求解器)
**日期**: 2025-12-29
**算法**: Branch and Price = Column Generation + Branch and Bound

---

## 目录

1. [问题描述](#1-问题描述)
2. [符号定义](#2-符号定义)
3. [主问题模型 (Master Problem)](#3-主问题模型-master-problem)
4. [子问题SP1: 宽度方向背包](#4-子问题sp1-宽度方向背包)
5. [子问题SP2: 长度方向背包](#5-子问题sp2-长度方向背包)
6. [Arc Flow网络模型](#6-arc-flow网络模型)
7. [列生成算法](#7-列生成算法)
8. [Arc分支策略](#8-arc分支策略)
9. [分支定价算法流程](#9-分支定价算法流程)

---

## 1. 问题描述

### 1.1 二维下料问题 (2D Cutting Stock Problem)

**给定**:
- 固定尺寸的母板 (Stock Plate): 长度 $L \times$ 宽度 $W$
- 多种子板类型 (Item Types): 每种有长度 $l_i$、宽度 $w_i$、需求量 $d_i$

**目标**:
- 最小化母板使用数量，切割出满足所有需求的子板

### 1.2 两阶段切割 (Two-Stage Cutting)

本项目采用两阶段正交切割模式:

```
母板 (L × W)
    │
    │ 第一阶段: 沿宽度方向切割 (产生条带)
    ▼
条带 (L × w_j)     ── 条带宽度 = 子板宽度
    │
    │ 第二阶段: 沿长度方向切割 (产生子板)
    ▼
子板 (l_i × w_i)
```

**约束**: 子板只能放入宽度匹配的条带，即 $w_i \leq w_j$

---

## 2. 符号定义

### 2.1 问题参数

| 符号 | 含义 | 说明 |
|:----:|------|------|
| $L$ | 母板长度 | 沿X轴方向 |
| $W$ | 母板宽度 | 沿Y轴方向 |
| $N$ | 子板类型数量 | $i = 1, \ldots, N$ |
| $J$ | 条带类型数量 | $j = 1, \ldots, J$ |
| $l_i$ | 子板 $i$ 的长度 | |
| $w_i$ | 子板 $i$ 的宽度 | |
| $d_i$ | 子板 $i$ 的需求量 | |
| $w_j$ | 条带 $j$ 的宽度 | 等于某种子板宽度 |

### 2.2 决策变量

| 符号 | 含义 | 说明 |
|:----:|------|------|
| $Y_k$ | 母板切割模式 $k$ 的使用次数 | $k = 1, \ldots, K$ (Y列) |
| $X_p$ | 条带切割模式 $p$ 的使用次数 | $p = 1, \ldots, P$ (X列) |

### 2.3 系数矩阵

| 符号 | 含义 | 说明 |
|:----:|------|------|
| $C_{jk}$ | 母板模式 $k$ 产出条带 $j$ 的数量 | Y列的条带系数 |
| $A_{jp}$ | 条带模式 $p$ 是否属于条带 $j$ | $\in \{0, 1\}$ |
| $B_{ip}$ | 条带模式 $p$ 产出子板 $i$ 的数量 | X列的子板系数 |

### 2.4 对偶变量

| 符号 | 含义 | 说明 |
|:----:|------|------|
| $v_j$ | 条带平衡约束的对偶价格 | $j = 1, \ldots, J$ |
| $\pi_i$ | 需求约束的对偶价格 | $i = 1, \ldots, N$ |

---

## 3. 主问题模型 (Master Problem)

### 3.1 完整主问题

$$
\begin{aligned}
\min \quad & \sum_{k=1}^{K} Y_k \\
\text{s.t.} \quad & \sum_{k=1}^{K} C_{jk} Y_k - \sum_{p: A_{jp}=1} X_p \geq 0, \quad j = 1, \ldots, J \quad \text{(条带平衡)} \\
& \sum_{p=1}^{P} B_{ip} X_p \geq d_i, \quad i = 1, \ldots, N \quad \text{(需求满足)} \\
& Y_k \geq 0, \quad k = 1, \ldots, K \\
& X_p \geq 0, \quad p = 1, \ldots, P
\end{aligned}
$$

### 3.2 约束解释

**条带平衡约束** (Strip Balance):

$$
\underbrace{\sum_{k=1}^{K} C_{jk} Y_k}_{\text{产出条带数}} - \underbrace{\sum_{p: A_{jp}=1} X_p}_{\text{消耗条带数}} \geq 0
$$

- 含义: 产出的 $j$ 型条带必须足够满足条带模式的消耗

**需求满足约束** (Demand):

$$
\underbrace{\sum_{p=1}^{P} B_{ip} X_p}_{\text{切出子板数}} \geq d_i
$$

- 含义: 切出的 $i$ 型子板必须满足需求量 $d_i$

### 3.3 对偶问题

$$
\begin{aligned}
\max \quad & \sum_{i=1}^{N} d_i \pi_i \\
\text{s.t.} \quad & \sum_{j=1}^{J} C_{jk} v_j \leq 1, \quad k = 1, \ldots, K \quad \text{(Y列约束)} \\
& -v_j + \sum_{i=1}^{N} B_{ip} \pi_i \leq 0, \quad p \in \mathcal{P}_j \quad \text{(X列约束)} \\
& v_j \geq 0, \quad j = 1, \ldots, J \\
& \pi_i \geq 0, \quad i = 1, \ldots, N
\end{aligned}
$$

其中 $\mathcal{P}_j$ 表示属于条带类型 $j$ 的所有条带模式集合。

---

## 4. 子问题SP1: 宽度方向背包

### 4.1 数学模型

SP1用于寻找能改进主问题的新Y列 (母板切割模式):

$$
\begin{aligned}
\max \quad & \sum_{j=1}^{J} v_j G_j \\
\text{s.t.} \quad & \sum_{j=1}^{J} w_j G_j \leq W \\
& G_j \in \mathbb{Z}_+, \quad j = 1, \ldots, J
\end{aligned}
$$

**变量**: $G_j$ = 该母板模式中 $j$ 型条带的切割数量

**目标函数系数**: $v_j$ = 条带 $j$ 的对偶价格 (条带平衡约束的对偶值)

**约束**: 所有条带宽度之和不超过母板宽度 $W$

### 4.2 Reduced Cost计算

Y列的Reduced Cost:

$$
\bar{c}_Y = 1 - \sum_{j=1}^{J} v_j G_j
$$

其中 $1$ 是Y列在目标函数中的系数。

**列生成判断**:
- 若 $\bar{c}_Y < 0$ (即 $\sum_j v_j G_j > 1$): 找到改进列，加入主问题
- 若 $\bar{c}_Y \geq 0$: SP1收敛，无改进Y列

### 4.3 代码实现位置

- CPLEX背包: `root_node_sub.cpp:SolveRootSP1Knapsack()`
- Arc Flow: `root_node_sub.cpp:SolveRootSP1ArcFlow()`
- 动态规划: `root_node_sub.cpp:SolveRootSP1DP()`

---

## 5. 子问题SP2: 长度方向背包

### 5.1 数学模型

SP2用于寻找能改进主问题的新X列 (条带切割模式):

$$
\begin{aligned}
\max \quad & \sum_{i: w_i \leq w_j} \pi_i D_i \\
\text{s.t.} \quad & \sum_{i: w_i \leq w_j} l_i D_i \leq L \\
& D_i \in \mathbb{Z}_+, \quad \forall i: w_i \leq w_j
\end{aligned}
$$

**变量**: $D_i$ = 该条带模式中 $i$ 型子板的切割数量

**目标函数系数**: $\pi_i$ = 子板 $i$ 的对偶价格 (需求约束的对偶值)

**约束**:
- 所有子板长度之和不超过条带长度 $L$
- 只考虑宽度不超过条带宽度的子板 ($w_i \leq w_j$)

### 5.2 Reduced Cost计算

X列的Reduced Cost:

$$
\bar{c}_X = v_j - \sum_{i: w_i \leq w_j} \pi_i D_i
$$

其中 $v_j$ 是该条带类型的对偶价格。

**列生成判断**:
- 若 $\bar{c}_X < 0$ (即 $\sum_i \pi_i D_i > v_j$): 找到改进列，加入主问题
- 若 $\bar{c}_X \geq 0$: SP2($j$)收敛，无改进X列

### 5.3 代码实现位置

- CPLEX背包: `root_node_sub.cpp:SolveRootSP2Knapsack()`
- Arc Flow: `root_node_sub.cpp:SolveRootSP2ArcFlow()`
- 动态规划: `root_node_sub.cpp:SolveRootSP2DP()`

---

## 6. Arc Flow网络模型

### 6.1 Arc Flow基本概念

Arc Flow将背包问题转化为网络流问题:

- **节点**: 表示已使用的容量位置 $\{0, 1, 2, \ldots, C\}$，其中 $C$ 为容量
- **Arc**: $\text{Arc}(i, j)$ 表示在位置 $i$ 放置一个尺寸为 $(j-i)$ 的物品
- **路径**: 从节点 $0$ 到终点的路径对应一个装载方案

### 6.2 SP1 Arc Flow网络 (宽度方向)

**网络结构**:
- 节点集合: $\mathcal{V} = \{0, 1, 2, \ldots, W\}$
- Arc集合: $\mathcal{A} = \{(i, j) : j - i = w_s \text{ 对某条带类型 } s, \, 0 \leq i < j \leq W\}$

**数学模型**:

$$
\begin{aligned}
\max \quad & \sum_{(i,j) \in \mathcal{A}} v_{s(i,j)} \cdot a_{ij} \\
\text{s.t.} \quad & \sum_{(0,j) \in \mathcal{A}} a_{0j} = 1 & \text{(起点约束)} \\
& \sum_{(i,W) \in \mathcal{A}} a_{iW} = 1 & \text{(终点约束)} \\
& \sum_{(i,n) \in \mathcal{A}} a_{in} = \sum_{(n,j) \in \mathcal{A}} a_{nj}, \quad \forall n \in \mathcal{V} \setminus \{0, W\} & \text{(流量守恒)} \\
& \sum_{(i,j) \in \mathcal{A}} (j - i) \cdot a_{ij} \leq W & \text{(容量约束)} \\
& a_{ij} \in \{0, 1\}, \quad \forall (i,j) \in \mathcal{A}
\end{aligned}
$$

其中 $s(i,j)$ 表示Arc $(i,j)$ 对应的条带类型 (由Arc长度 $j-i$ 确定)。

### 6.3 SP2 Arc Flow网络 (长度方向)

**网络结构** (针对条带类型 $j$):
- 节点集合: $\mathcal{V}_j = \{0, 1, 2, \ldots, L\}$
- Arc集合: $\mathcal{A}_j = \{(i, k) : k - i = l_t \text{ 对某子板类型 } t \text{ 且 } w_t \leq w_j\}$

**数学模型**:

$$
\begin{aligned}
\max \quad & \sum_{(i,k) \in \mathcal{A}_j} \pi_{t(i,k)} \cdot a_{ik} \\
\text{s.t.} \quad & \sum_{(0,k) \in \mathcal{A}_j} a_{0k} = 1 & \text{(起点约束)} \\
& \sum_{(i,L) \in \mathcal{A}_j} a_{iL} = 1 & \text{(终点约束)} \\
& \sum_{(i,n) \in \mathcal{A}_j} a_{in} = \sum_{(n,k) \in \mathcal{A}_j} a_{nk}, \quad \forall n \in \mathcal{V}_j \setminus \{0, L\} & \text{(流量守恒)} \\
& a_{ik} \in \{0, 1\}, \quad \forall (i,k) \in \mathcal{A}_j
\end{aligned}
$$

其中 $t(i,k)$ 表示Arc $(i,k)$ 对应的子板类型。

### 6.4 Arc与Pattern的转换

**Pattern到Arc集合**:

给定切割方案 $\mathbf{G} = (G_1, G_2, \ldots, G_J)$ 和尺寸向量 $\mathbf{w} = (w_1, w_2, \ldots, w_J)$:

$$
\mathcal{S}(\mathbf{G}) = \left\lbrace \left( \sum_{s=1}^{j-1} \sum_{t=1}^{G_s} w_s + (k-1) w_j, \, \sum_{s=1}^{j-1} \sum_{t=1}^{G_s} w_s + k \cdot w_j \right) : j = 1, \ldots, J, \, k = 1, \ldots, G_j \right\rbrace
$$

**LP解到Arc流量**:

给定Y列集合及其LP解值 $\{(Y_k, \mathbf{G}^{(k)}, y_k^{*})\}$:

$$
f_{ij} = \sum_{k: (i,j) \in \mathcal{S}(\mathbf{G}^{(k)})} y_k^{*}
$$

其中 $f_{ij}$ 表示Arc $(i,j)$ 的总流量。

### 6.5 代码实现位置

- Arc网络生成: `arc_flow.cpp:GenerateSP1Arcs()`, `GenerateSP2Arcs()`
- LP解转换: `arc_flow.cpp:ConvertYColsToSP1ArcFlow()`, `ConvertXColsToSP2ArcFlow()`

---

## 7. 列生成算法

### 7.1 算法流程

```
输入: 初始列集合 (启发式生成)
输出: LP最优解

1. 构建初始主问题 (使用初始列)
2. 求解主问题LP, 获取对偶价格 (v_j, π_i)
3. 循环:
   a. 求解SP1, 寻找改进Y列
      - 若找到: 加入主问题, 转步骤2
      - 若收敛: 转步骤b
   b. 对每种条带类型j, 求解SP2(j)
      - 若找到改进X列: 加入主问题, 转步骤2
   c. 若所有SP2都收敛: 退出循环
4. 返回LP最优解
```

### 7.2 收敛条件

列生成收敛当且仅当:

$$
\begin{cases}
\displaystyle \max_{\mathbf{G}} \sum_{j=1}^{J} v_j G_j \leq 1 & \text{(SP1收敛)} \\
\displaystyle \max_{\mathbf{D}} \sum_{i: w_i \leq w_j} \pi_i D_i \leq v_j, \quad \forall j = 1, \ldots, J & \text{(所有SP2收敛)}
\end{cases}
$$

此时不存在能改进目标的新列，LP最优已达到。

### 7.3 代码实现位置

- 主循环: `root_node.cpp:SolveRootCG()`
- 初始主问题: `root_node.cpp:SolveRootInitMP()`
- 更新主问题: `root_node.cpp:SolveRootUpdateMP()`

---

## 8. Arc分支策略

### 8.1 分支原理

LP最优解可能是分数解，需要通过分支定界获得整数解。

Arc分支策略: 对分数流量的Arc进行分支。

设Arc $(i,j)$ 的流量为 $f_{ij}$，若 $f_{ij} \notin \mathbb{Z}$:

$$
\begin{cases}
\text{左分支}: & f_{ij} \leq \lfloor f_{ij} \rfloor \\
\text{右分支}: & f_{ij} \geq \lceil f_{ij} \rceil
\end{cases}
$$

### 8.2 分支类型

| 类型 | 说明 | 约束存储 |
|:----:|------|----------|
| `kBranchSP1Arc` | SP1宽度方向Arc分支 | `node.sp1_*_arcs_` |
| `kBranchSP2Arc` | SP2长度方向Arc分支 | `node.sp2_*_arcs_[j]` |

### 8.3 Arc约束类型

**禁用Arc约束** (Zero):

$$
a_{ij} = 0 \quad \text{(完全禁止使用该Arc)}
$$

- 产生条件: 左分支且 $\lfloor f_{ij} \rfloor = 0$
- 实现: `vars[arc_idx].setUB(0)`

**Arc上界约束** (Upper Bound):

$$
a_{ij} \leq N \quad \text{(流量不超过 } N \text{)}
$$

- 产生条件: 左分支且 $\lfloor f_{ij} \rfloor = N > 0$
- 实现: `vars[arc_idx].setUB(N)`

**Arc下界约束** (Lower Bound):

$$
a_{ij} \geq N \quad \text{(流量至少为 } N \text{)}
$$

- 产生条件: 右分支，$N = \lceil f_{ij} \rceil$
- 实现: `vars[arc_idx].setLB(N)`

### 8.4 分支选择策略

选择流量小数部分最接近 $0.5$ 的Arc进行分支:

$$
(i^{*}, j^{*}) = \arg\max_{(i,j): 0 < \lbrace f_{ij} \rbrace < 1} \left( 0.5 - \left| \lbrace f_{ij} \rbrace - 0.5 \right| \right)
$$

其中 $\lbrace f_{ij} \rbrace = f_{ij} - \lfloor f_{ij} \rfloor$ 表示小数部分。

**目标**: 选择使分支最平衡的Arc，加速收敛。

### 8.5 约束继承

设节点 $\nu$ 的Arc约束集为 $\mathcal{C}_\nu$，其子节点 $\nu'$ 继承所有父节点约束并添加新约束:

$$
\mathcal{C}_{\nu'} = \mathcal{C}_\nu \cup \{\text{新分支约束}\}
$$

### 8.6 代码实现位置

- 分支Arc选择: `branch_and_price.cpp:SelectBranchArc()`
- 创建子节点: `branch_and_price.cpp:CreateLeftChild()`, `CreateRightChild()`
- 约束应用: `new_node_sub.cpp:SolveNodeSP1ArcFlow()`, `SolveNodeSP2ArcFlow()`

---

## 9. 分支定价算法流程

### 9.1 完整算法流程

```
输入: 问题实例
输出: 最优整数解

1. 启发式: 生成初始可行解 (作为初始上界 UB)
2. 根节点列生成: 求解LP松弛, 获得下界 LB
3. 若LP解为整数: 返回最优解
4. 初始化: 将根节点加入待处理队列 Q

5. 分支定价主循环:
   while Q ≠ ∅ 且 未超时:
       a. 选择节点: ν ← arg min{LB(ν') : ν' ∈ Q}
       b. 选择分支Arc:
          - 优先检查SP1 Arc
          - 若SP1全整数, 检查SP2 Arc
          - 若全整数: 更新UB, continue
       c. 创建子节点:
          - 左子节点: Arc ≤ ⌊flow⌋
          - 右子节点: Arc ≥ ⌈flow⌉
       d. 求解子节点:
          - 列生成求解LP
          - 若不可行或 LB ≥ UB: 剪枝
          - 若整数解: 更新UB
          - 否则: 加入Q
       e. 更新全局最优下界
       f. 计算 Gap = (UB - LB) / UB
       g. 若 Gap ≤ 0: 找到最优解, 终止

6. 返回最优整数解
```

### 9.2 剪枝条件

节点 $\nu$ 被剪枝的条件:

$$
\text{Prune}(\nu) \Leftrightarrow \text{LP}(\nu) \text{ 不可行} \quad \text{或} \quad \text{LB}(\nu) \geq \text{UB}
$$

### 9.3 最优性证明

当 $\text{Gap} = 0$ 时:

$$
\text{UB} = \text{LB} \implies z^{*} = \text{UB}
$$

其中 $z^{*}$ 为全局最优值。此时当前整数解是全局最优。

### 9.4 最优性间隙 (Optimality Gap)

$$
\text{Gap} = \frac{\text{UB} - \text{LB}}{\text{UB}} \times 100\%
$$

其中:
- $\text{UB}$: 当前最优整数解的目标值 (上界)
- $\text{LB}$: 所有未剪枝节点下界的最小值 (全局下界)

### 9.5 代码实现位置

- 主循环: `branch_and_price.cpp:RunBranchAndPrice()`
- 节点选择: `branch_and_price.cpp:SelectBranchNode()`
- 整数性检查: `branch_and_price.cpp:IsIntegerSolution()`

---

## 附录A: 对偶价格解释

### A.1 条带平衡约束对偶 $v_j$

**经济含义**: 多产出一单位 $j$ 型条带能使目标改善 $v_j$

**取值范围**: $v_j \geq 0$ (约束为 $\geq$ 形式)

**应用**: SP1子问题的目标函数系数

### A.2 需求约束对偶 $\pi_i$

**经济含义**: 需求放松一单位能使目标改善 $\pi_i$

**取值范围**: $\pi_i \geq 0$ (约束为 $\geq$ 形式)

**应用**: SP2子问题的目标函数系数

---

## 附录B: 方法对比

### B.1 子问题求解方法对比

| 方法 | Arc约束支持 | 时间复杂度 | 适用场景 |
|:----:|:-----------:|:----------:|----------|
| `kCplexIP` | 不支持 | $O(?)$ | 仅根节点 |
| `kArcFlow` | **支持** | $O(?)$ | 分支定价必需 |
| `kDP` | 不支持 | $O(JW)$ / $O(NL)$ | 仅根节点 |

> **重要**: 使用Arc分支策略时，**必须**使用`kArcFlow`方法，否则分支约束无效!

### B.2 动态规划递推公式

**SP1 (完全背包)**:

$$
f(w) = \max_{j: w_j \leq w} \left\lbrace f(w - w_j) + v_j \right\rbrace, \quad w = 1, \ldots, W
$$

初始条件: $f(0) = 0$

**SP2 (完全背包)**:

$$
g(l) = \max_{i: l_i \leq l, w_i \leq w_j} \left\lbrace g(l - l_i) + \pi_i \right\rbrace, \quad l = 1, \ldots, L
$$

初始条件: $g(0) = 0$

---

## 附录C: 数据结构

### C.1 Y列 (YColumn)

```cpp
struct YColumn {
    vector<int> pattern_;        // pattern_[j] = j型条带的产出数量
    set<array<int,2>> arc_set_;  // 对应的SP1 Arc集合
    double value_;               // LP解值
    int var_index_;              // 在vars数组中的索引
};
```

### C.2 X列 (XColumn)

```cpp
struct XColumn {
    int strip_type_id_;          // 所属条带类型
    vector<int> pattern_;        // pattern_[i] = i型子板的产出数量
    set<array<int,2>> arc_set_;  // 对应的SP2 Arc集合
    double value_;               // LP解值
    int var_index_;              // 在vars数组中的索引
};
```

### C.3 Arc约束数据结构

**SP1 Arc约束** (节点级别):

| 变量 | 类型 | 含义 |
|------|------|------|
| `sp1_zero_arcs_` | `set<array<int,2>>` | 禁用的Arc集合 |
| `sp1_lower_arcs_` | `vector<array<int,2>>` | 上界约束的Arc列表 |
| `sp1_lower_bounds_` | `vector<int>` | 对应的上界值 |
| `sp1_greater_arcs_` | `vector<array<int,2>>` | 下界约束的Arc列表 |
| `sp1_greater_bounds_` | `vector<int>` | 对应的下界值 |

**SP2 Arc约束** (按条带类型存储):

| 变量 | 类型 | 含义 |
|------|------|------|
| `sp2_zero_arcs_` | `map<int, set<...>>` | 各条带类型禁用的Arc |
| `sp2_lower_arcs_` | `map<int, vector<...>>` | 各条带类型的上界约束Arc |
| `sp2_lower_bounds_` | `map<int, vector<int>>` | 对应的上界值 |
| `sp2_greater_arcs_` | `map<int, vector<...>>` | 各条带类型的下界约束Arc |
| `sp2_greater_bounds_` | `map<int, vector<int>>` | 对应的下界值 |

---

**文档编写**: Claude Code
**验证平台**: Windows WSL2 + MSVC 2022 + CPLEX 22.1.0
