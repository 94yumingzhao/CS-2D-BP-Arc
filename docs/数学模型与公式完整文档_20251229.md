# CS-2D-BP-Arc 数学模型与公式完整文档

**项目**: CS-2D-BP-Arc (二维下料问题分支定价求解器)
**日期**: 2025-12-29
**算法**: Branch and Price = Column Generation + Branch and Bound

---

## 目录

1. [问题描述](#1-问题描述)
2. [符号定义](#2-符号定义)
3. [主问题模型 (Master Problem)](#3-主问题模型-master-problem)
4. [子问题SP1: 宽度方向背包](#4-子问题sp1-宽度方向背包)
5. [子问题SP2: 长度方向背包](#5-子问题sp2-长度方向背包)
6. [Arc Flow网络模型](#6-arc-flow网络模型)
7. [列生成算法](#7-列生成算法)
8. [Arc分支策略](#8-arc分支策略)
9. [分支定价算法流程](#9-分支定价算法流程)

---

## 1. 问题描述

### 1.1 二维下料问题 (2D Cutting Stock Problem)

给定:
- 固定尺寸的母板 (Stock Plate): 长度 L x 宽度 W
- 多种子板类型 (Item Types): 每种有长度 l_i、宽度 w_i、需求量 d_i

目标:
- **最小化母板使用数量**, 切割出满足所有需求的子板

### 1.2 两阶段切割 (Two-Stage Cutting)

本项目采用两阶段正交切割模式:

```
母板 (L x W)
    |
    | 第一阶段: 沿宽度方向切割 (产生条带)
    v
条带 (L x w_j)     -- 条带宽度 = 子板宽度
    |
    | 第二阶段: 沿长度方向切割 (产生子板)
    v
子板 (l_i x w_i)
```

**约束**: 子板只能放入宽度匹配的条带 (w_i <= w_j)

---

## 2. 符号定义

### 2.1 问题参数

| 符号 | 含义 | 说明 |
|------|------|------|
| L | 母板长度 | 沿X轴方向 |
| W | 母板宽度 | 沿Y轴方向 |
| N | 子板类型数量 | i = 1, ..., N |
| J | 条带类型数量 | j = 1, ..., J |
| l_i | 子板i的长度 | |
| w_i | 子板i的宽度 | |
| d_i | 子板i的需求量 | |
| w_j | 条带j的宽度 | 等于某种子板宽度 |

### 2.2 决策变量

| 符号 | 含义 | 说明 |
|------|------|------|
| Y_k | 母板切割模式k的使用次数 | k = 1, ..., K (Y列) |
| X_p | 条带切割模式p的使用次数 | p = 1, ..., P (X列) |

### 2.3 系数矩阵

| 符号 | 含义 | 说明 |
|------|------|------|
| C_{jk} | 母板模式k产出条带j的数量 | Y列的条带系数 |
| A_{jp} | 条带模式p是否属于条带j | 1或0 |
| B_{ip} | 条带模式p产出子板i的数量 | X列的子板系数 |

### 2.4 对偶变量

| 符号 | 含义 | 说明 |
|------|------|------|
| v_j | 条带平衡约束的对偶价格 | j = 1, ..., J |
| pi_i | 需求约束的对偶价格 | i = 1, ..., N |

---

## 3. 主问题模型 (Master Problem)

### 3.1 完整主问题

```
min  sum_{k=1}^{K} Y_k

s.t. sum_{k=1}^{K} C_{jk} * Y_k - sum_{p:A_{jp}=1} X_p >= 0    (j = 1,...,J)  [条带平衡]

     sum_{p=1}^{P} B_{ip} * X_p >= d_i                          (i = 1,...,N)  [需求满足]

     Y_k >= 0                                                   (k = 1,...,K)
     X_p >= 0                                                   (p = 1,...,P)
```

### 3.2 约束解释

**条带平衡约束** (Strip Balance):
```
产出条带数 - 消耗条带数 >= 0
```
- 左边: 所有Y列产出的j型条带总数
- 右边: 所有属于j型的X列的使用次数 (消耗)
- 含义: 产出的条带必须足够满足条带模式的消耗

**需求满足约束** (Demand):
```
切出子板数 >= 需求量
```
- 左边: 所有X列产出的i型子板总数
- 右边: i型子板的需求量 d_i
- 含义: 切出的子板必须满足需求

### 3.3 对偶问题

```
max  sum_{i=1}^{N} d_i * pi_i

s.t. sum_{j=1}^{J} C_{jk} * v_j <= 1                           (k = 1,...,K)  [Y列约束]

     -v_j + sum_{i=1}^{N} B_{ip} * pi_i <= 0                   (p属于条带j)   [X列约束]

     v_j >= 0                                                   (j = 1,...,J)
     pi_i >= 0                                                  (i = 1,...,N)
```

### 3.4 LP松弛

在列生成过程中,求解的是LP松弛问题 (变量连续), LP最优解作为节点下界.

---

## 4. 子问题SP1: 宽度方向背包

### 4.1 数学模型

SP1用于寻找能改进主问题的新Y列 (母板切割模式):

```
max  sum_{j=1}^{J} v_j * G_j

s.t. sum_{j=1}^{J} w_j * G_j <= W

     G_j >= 0, 整数                     (j = 1,...,J)
```

**变量**: G_j = 该母板模式中j型条带的切割数量

**目标函数系数**: v_j = 条带j的对偶价格 (条带平衡约束的对偶值)

**约束**: 所有条带宽度之和不超过母板宽度 W

### 4.2 Reduced Cost计算

Y列的Reduced Cost:
```
RC_Y = sum_{j} v_j * G_j - 1
```

其中 1 是Y列在目标函数中的系数.

**列生成判断**:
- 若 RC_Y > 0 (即 sum_j v_j * G_j > 1): 找到改进列, 加入主问题
- 若 RC_Y <= 0: SP1收敛, 无改进Y列

### 4.3 代码实现位置

- CPLEX背包: `root_node_sub.cpp:SolveRootSP1Knapsack()`
- Arc Flow: `root_node_sub.cpp:SolveRootSP1ArcFlow()`
- 动态规划: `root_node_sub.cpp:SolveRootSP1DP()`

---

## 5. 子问题SP2: 长度方向背包

### 5.1 数学模型

SP2用于寻找能改进主问题的新X列 (条带切割模式):

```
max  sum_{i: w_i <= w_j} pi_i * D_i

s.t. sum_{i: w_i <= w_j} l_i * D_i <= L

     D_i >= 0, 整数                     (i: w_i <= w_j)
```

**变量**: D_i = 该条带模式中i型子板的切割数量

**目标函数系数**: pi_i = 子板i的对偶价格 (需求约束的对偶值)

**约束**:
- 所有子板长度之和不超过母板长度 L (= 条带长度)
- 只考虑宽度不超过条带宽度的子板 (w_i <= w_j)

### 5.2 Reduced Cost计算

X列的Reduced Cost:
```
RC_X = sum_{i} pi_i * D_i - v_j
```

其中 v_j 是该条带类型的对偶价格.

**列生成判断**:
- 若 RC_X > 0 (即 sum_i pi_i * D_i > v_j): 找到改进列, 加入主问题
- 若 RC_X <= 0: SP2(j)收敛, 无改进X列

### 5.3 代码实现位置

- CPLEX背包: `root_node_sub.cpp:SolveRootSP2Knapsack()`
- Arc Flow: `root_node_sub.cpp:SolveRootSP2ArcFlow()`
- 动态规划: `root_node_sub.cpp:SolveRootSP2DP()`

---

## 6. Arc Flow网络模型

### 6.1 Arc Flow基本概念

Arc Flow将背包问题转化为网络流问题:

- **节点**: 表示已使用的容量位置 (0, 1, 2, ..., Capacity)
- **Arc**: 表示在某位置放置一个物品
- **路径**: 从节点0到终点的路径对应一个装载方案

### 6.2 SP1 Arc Flow网络 (宽度方向)

**网络结构**:
```
节点: 0, 1, 2, ..., W  (母板宽度方向位置)
Arc(i,j): 在位置i放置宽度为(j-i)的条带
```

**变量**: a_k = Arc k的流量 (0-1整数)

**数学模型**:
```
max  sum_{k} v_{strip(k)} * a_k

s.t. sum_{k: start(k)=0} a_k = 1                           [起点约束]

     sum_{k: end(k)=W} a_k = 1                             [终点约束]

     sum_{k: end(k)=n} a_k = sum_{k: start(k)=n} a_k       [流量守恒, n为中间节点]

     sum_{k} (end(k)-start(k)) * a_k <= W                  [容量约束]

     a_k in {0, 1}                                         (所有Arc)
```

**函数映射**:
- strip(k): Arc k对应的条带类型 (由Arc长度确定)
- v_{strip(k)}: 该条带类型的对偶价格

### 6.3 SP2 Arc Flow网络 (长度方向)

**网络结构**:
```
节点: 0, 1, 2, ..., L  (条带长度方向位置)
Arc(i,j): 在位置i放置长度为(j-i)的子板
```

每种条带类型有独立的SP2网络, 只包含宽度匹配的子板对应的Arc.

**数学模型**:
```
max  sum_{k} pi_{item(k)} * a_k

s.t. sum_{k: start(k)=0} a_k = 1                           [起点约束]

     sum_{k: end(k)=L} a_k = 1                             [终点约束]

     sum_{k: end(k)=n} a_k = sum_{k: start(k)=n} a_k       [流量守恒]

     sum_{k} (end(k)-start(k)) * a_k <= L                  [容量约束]

     a_k in {0, 1}                                         (所有Arc)
```

### 6.4 Arc与Pattern的转换

**Pattern到Arc集合**:
```cpp
// 输入: pattern = [2, 0, 1] (条带0放2个, 条带1放0个, 条带2放1个)
// 输入: sizes = [100, 80, 60] (各条带宽度)
// 输出: arc_set = {(0,100), (100,200), (200,260)}

void ConvertPatternToArcSet(pattern, sizes, arc_set) {
    pos = 0;
    for (i = 0; i < pattern.size(); i++) {
        for (k = 0; k < pattern[i]; k++) {
            arc_set.insert({pos, pos + sizes[i]});
            pos += sizes[i];
        }
    }
}
```

**LP解到Arc流量**:
```cpp
// 输入: Y列集合, 每列有pattern和value
// 输出: arc_flow[arc_idx] = (start, end, total_flow)

void ConvertYColsToSP1ArcFlow(y_columns, arc_flow) {
    for (col : y_columns) {
        if (col.value == 0) continue;
        arc_set = PatternToArcSet(col.pattern);
        for (arc : arc_set) {
            arc_flow[arc] += col.value;
        }
    }
}
```

### 6.5 代码实现位置

- Arc网络生成: `arc_flow.cpp:GenerateSP1Arcs()`, `GenerateSP2Arcs()`
- LP解转换: `arc_flow.cpp:ConvertYColsToSP1ArcFlow()`, `ConvertXColsToSP2ArcFlow()`

---

## 7. 列生成算法

### 7.1 算法流程

```
输入: 初始列集合 (启发式生成)
输出: LP最优解

1. 构建初始主问题 (使用初始列)
2. 求解主问题LP, 获取对偶价格 (v_j, pi_i)
3. 循环:
   a. 求解SP1, 寻找改进Y列
      - 若找到: 加入主问题, 转步骤2
      - 若收敛: 转步骤b
   b. 对每种条带类型j, 求解SP2(j)
      - 若找到改进X列: 加入主问题, 转步骤2
   c. 若所有SP2都收敛: 退出循环
4. 返回LP最优解
```

### 7.2 收敛条件

列生成收敛当且仅当:

1. **SP1收敛**: max sum_j v_j * G_j <= 1
2. **所有SP2收敛**: 对所有j, max sum_i pi_i * D_i <= v_j

此时不存在能改进目标的新列, LP最优已达到.

### 7.3 代码实现位置

- 主循环: `root_node.cpp:SolveRootCG()`
- 初始主问题: `root_node.cpp:SolveRootInitMP()`
- 更新主问题: `root_node.cpp:SolveRootUpdateMP()`

---

## 8. Arc分支策略

### 8.1 分支原理

LP最优解可能是分数解, 需要通过分支定界获得整数解.

Arc分支策略: 对分数流量的Arc进行分支

```
若Arc(i,j)的流量 f 为分数 (0 < frac(f) < 1):
    左分支: Arc(i,j) 流量 <= floor(f)
    右分支: Arc(i,j) 流量 >= ceil(f)
```

### 8.2 分支类型

| 类型 | 说明 | 约束存储 |
|------|------|----------|
| kBranchSP1Arc | SP1宽度方向Arc分支 | node.sp1_*_arcs_ |
| kBranchSP2Arc | SP2长度方向Arc分支 | node.sp2_*_arcs_[strip_type] |

### 8.3 Arc约束类型

**禁用Arc约束** (Zero):
```
Arc(i,j) 流量 = 0  (完全禁止使用该Arc)
```
- 产生条件: 左分支且 floor(f) = 0
- 实现: `vars[arc_idx].setUB(0)`

**Arc上界约束** (Lower/Upper):
```
Arc(i,j) 流量 <= N  (流量不超过N)
```
- 产生条件: 左分支且 floor(f) > 0
- 实现: `vars[arc_idx].setUB(N)`

**Arc下界约束** (Greater):
```
Arc(i,j) 流量 >= N  (流量至少为N)
```
- 产生条件: 右分支
- 实现: `vars[arc_idx].setLB(N)`

### 8.4 分支选择策略

选择流量最接近0.5的分数Arc进行分支:
```cpp
// 目标: 选择使分支最平衡的Arc
best_arc = null;
best_score = -1;

for (arc : all_arcs) {
    flow = arc.flow;
    frac = flow - floor(flow);

    if (frac > 0.0001 && frac < 0.9999) {  // 分数流量
        score = 0.5 - abs(frac - 0.5);      // 越接近0.5分数越高
        if (score > best_score) {
            best_arc = arc;
            best_score = score;
        }
    }
}
```

### 8.5 约束继承

子节点继承父节点的所有Arc约束, 并添加新的分支约束:

```cpp
void CreateLeftChild(parent, child) {
    // 继承父节点约束
    child.sp1_zero_arcs_ = parent.sp1_zero_arcs_;
    child.sp1_lower_arcs_ = parent.sp1_lower_arcs_;
    child.sp1_lower_bounds_ = parent.sp1_lower_bounds_;
    child.sp1_greater_arcs_ = parent.sp1_greater_arcs_;
    child.sp1_greater_bounds_ = parent.sp1_greater_bounds_;

    // 添加新的分支约束 (左分支: <= floor)
    if (parent.branch_type_ == kBranchSP1Arc) {
        int bound = floor(parent.branch_arc_flow_);
        if (bound == 0) {
            child.sp1_zero_arcs_.insert(parent.branch_arc_);
        } else {
            child.sp1_lower_arcs_.push_back(parent.branch_arc_);
            child.sp1_lower_bounds_.push_back(bound);
        }
    }
}
```

### 8.6 代码实现位置

- 分支Arc选择: `branch_and_price.cpp:SelectBranchArc()`
- 创建子节点: `branch_and_price.cpp:CreateLeftChild()`, `CreateRightChild()`
- 约束应用: `new_node_sub.cpp:SolveNodeSP1ArcFlow()`, `SolveNodeSP2ArcFlow()`

---

## 9. 分支定价算法流程

### 9.1 完整算法流程

```
输入: 问题实例
输出: 最优整数解

1. 启发式: 生成初始可行解 (作为初始上界UB)
2. 根节点列生成: 求解LP松弛, 获得下界LB
3. 若LP解为整数: 返回最优解
4. 初始化: 将根节点加入待处理队列

5. 分支定价主循环:
   while (队列非空 且 未超时):
       a. 选择节点: 选择下界最小的未剪枝节点
       b. 选择分支Arc:
          - 优先检查SP1 Arc
          - 若SP1全整数, 检查SP2 Arc
          - 若全整数: 更新UB, 继续循环
       c. 创建子节点:
          - 左子节点: Arc <= floor(flow)
          - 右子节点: Arc >= ceil(flow)
       d. 求解子节点:
          - 列生成求解LP
          - 若不可行或LB >= UB: 剪枝
          - 若整数解: 更新UB
          - 否则: 加入队列
       e. 更新全局最优下界
       f. 计算Gap = (UB - LB) / UB
       g. 若Gap <= 0: 找到最优解, 终止

6. 返回最优整数解
```

### 9.2 剪枝条件

节点被剪枝的条件:
1. **不可行**: LP松弛无可行解
2. **界剪枝**: 节点下界 >= 当前最优整数解上界

### 9.3 最优性证明

当Gap = 0时:
```
UB = LB
=> 当前整数解目标值 = 所有未探索节点可能达到的最优值
=> 当前整数解是全局最优
```

### 9.4 代码实现位置

- 主循环: `branch_and_price.cpp:RunBranchAndPrice()`
- 节点选择: `branch_and_price.cpp:SelectBranchNode()`
- 整数性检查: `branch_and_price.cpp:IsIntegerSolution()`

---

## 附录A: 对偶价格解释

### A.1 条带平衡约束对偶 v_j

**经济含义**: 多产出一单位j型条带能使目标改善v_j

**取值范围**: v_j >= 0 (约束为>=形式)

**应用**: SP1子问题的目标函数系数

### A.2 需求约束对偶 pi_i

**经济含义**: 需求放松一单位能使目标改善pi_i

**取值范围**: pi_i >= 0 (约束为>=形式)

**应用**: SP2子问题的目标函数系数

---

## 附录B: 方法对比

### B.1 子问题求解方法对比

| 方法 | Arc约束支持 | 性能 | 适用场景 |
|------|-------------|------|----------|
| kCplexIP | 不支持 | 中等 | 仅根节点 |
| kArcFlow | 支持 | 较慢 | 分支定价必需 |
| kDP | 不支持 | 最快 | 仅根节点 |

**重要**: 使用Arc分支策略时, **必须**使用kArcFlow方法, 否则分支约束无效!

### B.2 分支策略对比

| 策略 | 优点 | 缺点 |
|------|------|------|
| 变量分支 | 实现简单 | 子问题需要复杂约束 |
| Arc分支 | 自然适配Arc Flow | 需要Arc Flow方法 |

---

## 附录C: 数据结构

### C.1 Y列 (YColumn)

```cpp
struct YColumn {
    vector<int> pattern_;        // pattern_[j] = j型条带的产出数量
    set<array<int,2>> arc_set_;  // 对应的SP1 Arc集合
    double value_;               // LP解值
    int var_index_;              // 在vars数组中的索引
};
```

### C.2 X列 (XColumn)

```cpp
struct XColumn {
    int strip_type_id_;          // 所属条带类型
    vector<int> pattern_;        // pattern_[i] = i型子板的产出数量
    set<array<int,2>> arc_set_;  // 对应的SP2 Arc集合
    double value_;               // LP解值
    int var_index_;              // 在vars数组中的索引
};
```

### C.3 Arc约束存储

```cpp
// SP1 Arc约束 (节点级别)
set<array<int,2>> sp1_zero_arcs_;        // 禁用的Arc
vector<array<int,2>> sp1_lower_arcs_;    // 上界约束的Arc
vector<int> sp1_lower_bounds_;           // 对应的上界值
vector<array<int,2>> sp1_greater_arcs_;  // 下界约束的Arc
vector<int> sp1_greater_bounds_;         // 对应的下界值

// SP2 Arc约束 (按条带类型存储)
map<int, set<array<int,2>>> sp2_zero_arcs_;
map<int, vector<array<int,2>>> sp2_lower_arcs_;
map<int, vector<int>> sp2_lower_bounds_;
map<int, vector<array<int,2>>> sp2_greater_arcs_;
map<int, vector<int>> sp2_greater_bounds_;
```

---

**文档编写**: Claude Code
**验证平台**: Windows WSL2 + MSVC 2022 + CPLEX 22.1.0
