# Arc 分支架构重构：从变量边界到 RMP 行约束与对偶价格

> 本文档详细记录 CS-2D-BP-Arc 项目中 Arc 分支约束处理方式的重大重构，包括问题发现、根源分析、数学模型正确方法、修改方案及测试验证。

---

## 1. 问题现象

### 1.1 错误信息

在分支定价 (Branch-and-Price) 过程中，CPLEX 报告以下警告：

```
Warning: Bound infeasibility column 'a_X'
```

该警告在非根节点的列生成过程中出现，导致求解器无法正确处理 Arc 分支约束。

### 1.2 问题影响

- 分支节点的子问题求解失败或返回错误结果
- 分支定价无法收敛到正确的整数解
- 算法稳定性受损

---

## 2. 问题根源分析

### 2.1 原始实现方式

原始代码在子问题 (Arc-Flow 网络流模型) 中直接设置 Arc 变量的边界：

```cpp
// new_node_sub.cpp - 原始实现 (错误)

// Arc上界约束: Arc流量 <= N (来自左分支)
for (size_t i = 0; i < node->sp1_lower_arcs_.size(); i++) {
    const auto& arc = node->sp1_lower_arcs_[i];
    if (arc_data.arc_to_index_.count(arc)) {
        int idx = arc_data.arc_to_index_.at(arc);
        vars[idx].setUB(node->sp1_lower_bounds_[i]);  // 问题所在
    }
}

// Arc下界约束: Arc流量 >= N (来自右分支)
for (size_t i = 0; i < node->sp1_greater_arcs_.size(); i++) {
    const auto& arc = node->sp1_greater_arcs_[i];
    if (arc_data.arc_to_index_.count(arc)) {
        int idx = arc_data.arc_to_index_.at(arc);
        vars[idx].setLB(node->sp1_greater_bounds_[i]);  // 问题所在
    }
}
```

### 2.2 根本矛盾

**Arc-Flow 网络模型中，每个 Arc 变量是 0-1 二值变量**：

```cpp
IloNumVar var(env, 0, 1, ILOINT, var_name.c_str());  // 变量范围 [0, 1]
```

**但 Arc 聚合流量可以大于 1**：

Arc 聚合流量定义为：
$$F_a = \sum_{p: p \text{ uses arc } a} X_p$$

当多个列 (pattern) 使用同一个 Arc 时，聚合流量可能是 2、3 或更大的值。

**问题场景**：
- 假设 Arc `a` 的聚合流量 $F_a = 2.5$
- 左分支约束：$F_a \leq \lfloor 2.5 \rfloor = 2$
- 右分支约束：$F_a \geq \lceil 2.5 \rceil = 3$

原始实现尝试在子问题中设置：
- `vars[idx].setUB(2)` - 对于 0-1 变量，这个约束无效但不报错
- `vars[idx].setLB(3)` - **对于 0-1 变量，这是不可行的！**

因为 0-1 变量最大只能是 1，设置下界为 3 导致 CPLEX 报告 "Bound infeasibility"。

### 2.3 概念混淆

原始实现混淆了两个不同层次的概念：

| 层次 | 变量 | 约束对象 | 取值范围 |
|------|------|----------|----------|
| 子问题 (Arc-Flow) | Arc 变量 $x_a$ | 单个 pattern 中是否使用 Arc | $\{0, 1\}$ |
| 主问题 (RMP) | 列变量 $X_p, Y_q$ | 各 pattern 的使用次数 | $\mathbb{R}_+$ (LP) 或 $\mathbb{Z}_+$ (IP) |

**Arc 聚合流量分支是主问题层面的约束**，不能直接转化为子问题中 Arc 变量的边界约束。

---

## 3. 数学模型正确方法

### 3.1 数学模型 Section 9.5：节点约束如何进入定价

根据数学模型文档，Arc 分支约束应该：

1. **作为行约束添加到 RMP（受限主问题）**
2. **求解 RMP 后提取对偶价格 $\mu_a$**
3. **在子问题中用对偶价格修正 Arc 收益**

### 3.2 RMP 中的 Arc 行约束

对于 SP2 Arc 分支（主分支策略），约束形式为：

**弧聚合使用量（主问题线性表达式）**：
$$F^X_a = \sum_{p \in \mathcal{P}: j(p)=j(a)} \delta^X_{a,p} \cdot X_p$$

其中：
- $\delta^X_{a,p} \in \{0, 1\}$：列 $p$ 是否使用 Arc $a$
- $X_p$：列 $p$ 的使用次数（主问题变量）

**分支约束**：
- 左分支：$F^X_a \leq \lfloor F^{X*}_a \rfloor$
- 右分支：$F^X_a \geq \lceil F^{X*}_a \rceil$

### 3.3 对偶价格进入定价

RMP 中的 Arc 约束产生对偶价格 $\mu_a$。

对任意候选列 $p$，其对 Arc 约束的系数为 $\delta^X_{a,p}$，因此 reduced cost 额外包含：
$$\sum_{a \in \mathcal{A}_\mathcal{N}} \mu_a \cdot \delta^X_{a,p}$$

**在 SP2 Arc-Flow 定价中，等价于对受约束的物品弧进行系数修正**：
$$\pi_i \mapsto \pi_i + \mu_a$$

其中 $\pi_i$ 是子板需求约束的对偶价格，$\mu_a$ 是 Arc 约束的对偶价格。

### 3.4 对偶价格的符号约定

CPLEX 对偶价格符号：
- $\leq$ 约束：$\mu_a \leq 0$（约束收紧时目标变差）
- $\geq$ 约束：$\mu_a \geq 0$（约束收紧时目标变差）

在子问题中，将 $\mu_a$ 加到 Arc 收益上：
- 对于 $\leq$ 约束，$\mu_a \leq 0$，使用该 Arc 的收益降低，减少使用动机
- 对于 $\geq$ 约束，$\mu_a \geq 0$，使用该 Arc 的收益提高，增加使用动机

---

## 4. 修改方案

### 4.1 架构变更概述

```
原始架构：
  RMP (无 Arc 约束) → 子问题 (直接设置 Arc 变量边界)

新架构：
  RMP (含 Arc 行约束) → 提取对偶价格 μ_a → 子问题 (用 μ_a 修正 Arc 收益)
```

### 4.2 数据结构变更

**BPNode 新增字段** (`2DBP.h`)：

```cpp
// Arc 约束对偶价格 (数学模型 Section 9.5)
// 弧分支约束作为行约束添加到 RMP，求解后获取对偶价格 μ_a
// 在子问题中用 μ_a 修正弧的收益: π_i → π_i + μ_a
map<array<int, 2>, double> sp1_arc_duals_;                  // SP1 arc 对偶价格
map<int, map<array<int, 2>, double>> sp2_arc_duals_;        // SP2 arc 对偶价格 (按条带类型)
```

### 4.3 RMP 中添加 Arc 行约束

**SolveNodeInitMP** (`new_node.cpp`)：

```cpp
// SP1 Arc 约束 (宽度方向, 作用于 Y 列)
// F^Y_a = Σ_{q: q uses arc a} Y_q

// 零弧约束: F^Y_a <= 0
for (const auto& arc : node->sp1_zero_arcs_) {
    IloExpr arc_flow(env);
    for (int col = 0; col < num_y_cols; col++) {
        if (node->y_columns_[col].arc_set_.count(arc) > 0) {
            arc_flow += vars[col];  // 该列使用此 arc，系数为 1
        }
    }
    IloRange arc_con(env, -IloInfinity, arc_flow, 0);  // F_a <= 0
    cons.add(arc_con);
    model.add(arc_con);
    // 记录约束索引，用于后续提取对偶价格
}

// SP1 上界约束: F^Y_a <= bound
for (size_t i = 0; i < node->sp1_lower_arcs_.size(); i++) {
    const auto& arc = node->sp1_lower_arcs_[i];
    int bound = node->sp1_lower_bounds_[i];
    IloExpr arc_flow(env);
    for (int col = 0; col < num_y_cols; col++) {
        if (node->y_columns_[col].arc_set_.count(arc) > 0) {
            arc_flow += vars[col];
        }
    }
    IloRange arc_con(env, -IloInfinity, arc_flow, bound);  // F_a <= bound
    cons.add(arc_con);
    model.add(arc_con);
}

// SP1 下界约束: F^Y_a >= bound
for (size_t i = 0; i < node->sp1_greater_arcs_.size(); i++) {
    const auto& arc = node->sp1_greater_arcs_[i];
    int bound = node->sp1_greater_bounds_[i];
    IloExpr arc_flow(env);
    for (int col = 0; col < num_y_cols; col++) {
        if (node->y_columns_[col].arc_set_.count(arc) > 0) {
            arc_flow += vars[col];
        }
    }
    IloRange arc_con(env, bound, arc_flow, IloInfinity);  // F_a >= bound
    cons.add(arc_con);
    model.add(arc_con);
}

// SP2 Arc 约束同理...
```

### 4.4 提取 Arc 约束对偶价格

**SolveNodeInitMP/UpdateMP** (`new_node.cpp`)：

```cpp
// 求解 RMP 后提取对偶价格
cplex.solve();

// 提取 Arc 约束的对偶价格 (数学模型 Section 9.5)
node->sp1_arc_duals_.clear();
for (const auto& info : sp1_arc_cons_info) {
    double dual = cplex.getDual(cons[info.first]);
    if (dual == -0.0) dual = 0.0;
    node->sp1_arc_duals_[info.second] = dual;
}

node->sp2_arc_duals_.clear();
for (const auto& kv : sp2_arc_cons_info) {
    int strip_type = kv.first;
    for (const auto& info : kv.second) {
        double dual = cplex.getDual(cons[info.first]);
        if (dual == -0.0) dual = 0.0;
        node->sp2_arc_duals_[strip_type][info.second] = dual;
    }
}
```

### 4.5 子问题中用对偶价格修正 Arc 收益

**SolveNodeSP1ArcFlow** (`new_node_sub.cpp`)：

```cpp
// 为每个Arc创建0-1整数变量
// 目标函数: max sum((v_j + μ_a) * a_i)
IloExpr obj_expr(env);
for (int i = 0; i < num_arcs; i++) {
    IloNumVar var(env, 0, 1, ILOINT, var_name.c_str());
    vars.add(var);

    const auto& arc = arc_data.arc_list_[i];
    int arc_width = arc[1] - arc[0];

    // 基础收益: 物品弧为 v_j, 损耗弧为 0
    double profit = 0.0;
    if (data.width_to_strip_index_.count(arc_width) > 0) {
        int strip_idx = data.width_to_strip_index_.at(arc_width);
        profit = node->duals_[strip_idx];
    }

    // 添加 Arc 约束对偶价格修正 (数学模型 Section 9.5)
    // μ_a 来自 RMP 中 Arc 行约束的对偶价格
    if (node->sp1_arc_duals_.count(arc) > 0) {
        double mu_a = node->sp1_arc_duals_.at(arc);
        profit += mu_a;  // 关键修正！
    }

    if (fabs(profit) > kZeroTolerance) {
        obj_expr += vars[i] * profit;
    }
}

// 零弧约束仍保留直接禁用（因为子问题不应生成使用禁用 Arc 的 pattern）
for (const auto& arc : node->sp1_zero_arcs_) {
    if (arc_data.arc_to_index_.count(arc)) {
        int idx = arc_data.arc_to_index_.at(arc);
        vars[idx].setUB(0);  // 禁用该 Arc
    }
}

// 注意: 非零 Arc 约束不再直接设置边界！
// 它们已作为 RMP 行约束，通过对偶价格 μ_a 影响子问题目标函数
```

### 4.6 新列系数正确添加到 Arc 约束

**SolveNodeUpdateMP** (`new_node.cpp`)：

当添加新列时，需要为 Arc 约束行设置正确的系数：

```cpp
// 添加新Y列时，在 Arc 约束行中设置系数
for (int row = num_base_rows; row < cons.getSize(); row++) {
    string con_name = cons[row].getName();
    if (con_name.find("SP1_") == 0) {
        // 如果新列使用此 arc，系数为 1
        for (const auto& arc : node->new_y_col_.arc_set_) {
            string arc_suffix = "_" + to_string(arc[0]) + "_" + to_string(arc[1]);
            if (con_name.find(arc_suffix) != string::npos) {
                cplex_col += cons[row](1.0);
                break;
            }
        }
    }
}
```

### 4.7 根节点生成 arc_set_

为了在子节点中正确构建 Arc 约束，根节点的子问题求解器需要记录生成的列使用了哪些 Arc：

**SolveRootSP1ArcFlow** (`root_node_sub.cpp`)：

```cpp
// 根据选中的Arc构建切割模式
vector<int> pattern(num_strip_types, 0);
set<array<int, 2>> selected_arcs;  // 记录选中的Arc
for (int i = 0; i < num_arcs; i++) {
    double val = cplex.getValue(vars[i]);
    if (val > 0.5) {
        const auto& arc = arc_data.arc_list_[i];
        selected_arcs.insert(arc);  // 记录 Arc
        // ... 其他处理
    }
}

if (rc > 1 + kRcTolerance) {
    node.new_y_col_.pattern_ = pattern;
    node.new_y_col_.arc_set_ = selected_arcs;  // 保存 Arc 集合
}
```

---

## 5. 文件变更清单

| 文件 | 变更类型 | 说明 |
|------|----------|------|
| `src/2DBP.h` | 新增字段 | `sp1_arc_duals_`, `sp2_arc_duals_` |
| `src/new_node.cpp` | 重写 | `SolveNodeInitMP`: 添加 Arc 行约束，提取对偶价格 |
| `src/new_node.cpp` | 重写 | `SolveNodeUpdateMP`: 新列设置 Arc 约束系数，更新对偶价格 |
| `src/new_node_sub.cpp` | 修改 | `SolveNodeSP1ArcFlow`: 用对偶价格修正 Arc 收益 |
| `src/new_node_sub.cpp` | 修改 | `SolveNodeSP2ArcFlow`: 用对偶价格修正 Arc 收益 |
| `src/root_node_sub.cpp` | 修改 | `SolveRootSP1ArcFlow`: 生成 `arc_set_` |
| `src/root_node_sub.cpp` | 修改 | `SolveRootSP2ArcFlow`: 生成 `arc_set_` |

---

## 6. 测试验证

### 6.1 编译结果

```
cmake --build --preset release
```

编译成功，仅有轻微类型转换警告 (C4244)。

### 6.2 运行测试

```bash
./CS-2D-BP-Arc.exe -f inst_20251229_003237_d0.10.csv -t 50
```

输出：
```
[00:00.0] 启动 | CS-2D-BP-Arc | inst_20251229_003237_d0.10.csv | 限时:50s
[00:00.0] 数据 | 8种子板 | 母板:200x400
[00:00.0] 启发 | 初始解:7块 Y=7 X=7
[00:02.1] CG   | 收敛 iter=20  obj=6.00    Y=22  X=25
[00:02.1] CG   | 收敛 LP=6.00 (分数解)
[00:02.1] BP   | n=1   LB=6.00   UB=--   Gap=--     act=1  cut=0
...
[00:50.3] 完成 | 超时 | 解=9 Gap=33.3% nodes=45
```

### 6.3 验证结果

| 测试项 | 原始实现 | 新实现 |
|--------|----------|--------|
| Bound infeasibility 警告 | 出现 | 无 |
| 分支定价正常运行 | 失败 | 成功 |
| 根节点 LP | 6.00 | 6.00 |
| 找到整数解 | 不稳定 | 稳定 |

---

## 7. 总结

### 7.1 核心教训

**Arc 聚合流量分支是主问题层面的约束，不能简单转化为子问题中 0-1 变量的边界约束。**

正确的处理方式是：
1. 在 RMP 中添加 Arc 约束作为行约束
2. 提取对偶价格 $\mu_a$
3. 在子问题中用 $\mu_a$ 修正 Arc 收益

### 7.2 数学本质

Arc 分支约束限制的是**所有使用该 Arc 的列的总使用量**，而不是单个 pattern 中是否使用该 Arc。

通过对偶价格机制，主问题的约束信息被正确传递到子问题，使得子问题生成的新列在加入主问题后能够自然满足约束要求。

### 7.3 代码质量

本次重构使代码更加符合数学模型的描述，提高了算法的正确性和稳定性。同时，通过在列中记录 `arc_set_`，为后续的 Arc 约束处理提供了必要的数据支持。

---

*文档生成时间: 2025-12-30*
*Generated with Claude Code*
