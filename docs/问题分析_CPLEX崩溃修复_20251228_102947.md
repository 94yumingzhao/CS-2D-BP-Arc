# CS-2D-BP-Arc 求解器崩溃问题分析与修复

## 问题概述

在对CS-2D-BP-Arc求解器进行不同难度算例测试时,发现程序在列生成迭代过程中发生崩溃,
退出码为9 (Windows异常终止)。本文档记录完整的调试过程、问题根因分析及修复方案。

## 问题现象

### 测试环境
- 算例: `inst_20251228_083107_d0.05.csv` (6种子板类型, 总需求96)
- 母板尺寸: W=100, L=200
- 子问题方法: CPLEX Knapsack

### 崩溃表现
```
[MP-7] 更新并求解主问题
[MP] 目标值: 4.5000
[SP1-8] 节点1 求解SP1 (背包)
  [SP1] Reduced Cost: 1.0000
  [SP1] 收敛
[SP2-8] 条带类型0 求解SP2 (背包)
Exit code: 9
```

程序在第8次迭代的SP2求解过程中崩溃,没有任何错误信息输出。

## 调试过程

### 阶段1: 定位崩溃点

由于程序崩溃时没有输出错误信息,首先需要确定崩溃的精确位置。

**方法**: 在关键代码位置添加`cerr`输出 (标准错误流),避免缓冲区问题导致日志丢失。

```cpp
cerr << "[CERR] 进入SolveRootSP2Knapsack, strip_type_id=" << strip_type_id << endl;
cerr.flush();
```

**发现**: 崩溃发生在`SolveRootSP2Knapsack`函数的解提取阶段:

```cpp
// 崩溃点
for (int i = 0; i < num_item_types; i++) {
    double val = cplex.getValue(vars[i]);  // <-- 此处崩溃
    ...
}
```

### 阶段2: 发现第一个问题 - CPLEX对象生命周期

在添加更多调试日志后,发现一个可疑现象:程序有时在MP-8或MP-9崩溃,崩溃点不固定。

**分析`SolveRootUpdateMP`函数**:

```cpp
// 原始代码 (有问题)
bool SolveRootUpdateMP(...) {
    // ... 添加列到模型 ...

    IloCplex cplex(env);      // 每次调用都创建新对象
    cplex.extract(model);
    cplex.setOut(env.getNullStream());
    bool feasible = cplex.solve();

    // ... 提取对偶价格 ...

    cplex.end();              // 每次调用都销毁
    return true;
}
```

**问题根因**:

1. `SolveRootUpdateMP`在每次列生成迭代时被调用
2. 每次调用都创建新的`IloCplex`对象并调用`extract(model)`
3. 经过7-8次迭代后,CPLEX内部状态出现问题
4. 可能原因:
   - 内存碎片化
   - CPLEX内部引用计数错误
   - 模型与求解器对象的关联状态不一致

**修复方案**:

在`SolveRootCG`中创建单一`IloCplex`对象,通过引用传递给所有需要的函数:

```cpp
void SolveRootCG(ProblemParams& params, ProblemData& data, BPNode& root_node) {
    IloEnv env;
    IloModel model(env);
    // ...

    // 创建单一IloCplex对象并复用
    IloCplex cplex(env);
    cplex.setOut(env.getNullStream());

    // 传递给初始化函数
    bool feasible = SolveRootInitMP(params, data, env, model, obj, cons, vars,
                                     cplex, root_node);  // 传递cplex引用

    // 列生成循环中复用同一cplex对象
    while (true) {
        // ...
        SolveRootUpdateMP(params, data, env, model, obj, cons, vars,
                          cplex, root_node);  // 复用cplex
    }

    // 最后统一释放
    cplex.end();
    // ...
}
```

修改后的`SolveRootUpdateMP`:

```cpp
bool SolveRootUpdateMP(ProblemParams& params, ProblemData& data,
    IloEnv& env, IloModel& model, IloObjective& obj,
    IloRangeArray& cons, IloNumVarArray& vars,
    IloCplex& cplex, BPNode& node) {  // 接收cplex引用

    // ... 添加列 ...

    // 注意: 不需要重新extract, IloCplex会自动跟踪模型变化
    bool feasible = cplex.solve();  // 直接使用传入的cplex

    // ... 提取对偶价格 ...

    return true;  // 不再调用cplex.end()
}
```

### 阶段3: 发现第二个问题 - getValue调用未定义变量

修复第一个问题后,程序仍然崩溃,但崩溃点更加明确:

```
[CERR] 获取vars[4], vars size=6
[CERR] 调用getValue...
[CERR] val=4
[CERR] 获取vars[5], vars size=6
[CERR] 调用getValue...
Exit code: 9
```

**问题定位**:

在`SolveRootSP2Knapsack`中,SP2是为特定条带类型求解长度方向的背包问题。
关键约束是: **只有宽度小于等于条带宽度的子板才能放入该条带**。

查看代码结构:

```cpp
bool SolveRootSP2Knapsack(..., int strip_type_id) {
    int strip_width = data.strip_types_[strip_type_id].width_;

    // 构建目标函数
    for (int i = 0; i < num_item_types; i++) {
        IloNumVar var(env, 0, IloInfinity, ILOINT, var_name.c_str());
        vars.add(var);  // 所有变量都加入vars数组

        // 只考虑宽度匹配的子件
        if (data.item_types_[i].width_ <= strip_width) {
            double dual = node.duals_[num_strip_types + i];
            if (dual > 0) {
                obj_expr += vars[i] * dual;  // 只有匹配的变量加入目标
            }
        }
    }

    // 长度约束
    for (int i = 0; i < num_item_types; i++) {
        if (data.item_types_[i].width_ <= strip_width) {
            len_expr += data.item_types_[i].length_ * vars[i];  // 只有匹配的变量加入约束
        }
    }

    // 求解后提取解 (问题所在)
    for (int i = 0; i < num_item_types; i++) {
        double val = cplex.getValue(vars[i]);  // 对所有变量调用getValue!
        // ...
    }
}
```

**问题根因**:

1. `vars`数组包含所有6个子板类型的变量
2. 但只有宽度匹配的变量(如5个)被添加到目标函数和约束中
3. 宽度不匹配的变量(如vars[5])虽然存在于数组中,但**未被添加到CPLEX模型**
4. 对未在模型中的变量调用`getValue()`会导致未定义行为

**具体场景**:

| 子板索引 | 宽度 | 条带宽度=30 | 是否加入模型 |
|---------|------|-------------|-------------|
| 0 | 15 | <= 30 | 是 |
| 1 | 16 | <= 30 | 是 |
| 2 | 17 | <= 30 | 是 |
| 3 | 19 | <= 30 | 是 |
| 4 | 30 | <= 30 | 是 |
| 5 | 32 | > 30 | **否** |

当调用`cplex.getValue(vars[5])`时,由于vars[5]从未参与任何目标或约束,
CPLEX无法返回有效值,导致程序崩溃。

**修复方案**:

只对宽度匹配的变量调用`getValue()`:

```cpp
// 提取解
node.new_x_col_.pattern_.clear();
for (int i = 0; i < num_item_types; i++) {
    int int_val = 0;  // 默认值为0

    // 只对宽度匹配的变量获取值
    if (data.item_types_[i].width_ <= strip_width) {
        double val = cplex.getValue(vars[i]);
        int_val = (val - (int)val > 0.99999) ? (int)val + 1 : (int)val;
    }
    // 宽度不匹配的变量,int_val保持为0

    node.new_x_col_.pattern_.push_back(int_val);
}
```

## 修改的文件清单

### 1. src/2DBP.h

更新函数签名,添加`IloCplex&`参数:

```cpp
// 构建根节点初始主问题 (复用cplex对象)
bool SolveRootInitMP(ProblemParams& params, ProblemData& data,
    IloEnv& env, IloModel& model, IloObjective& obj,
    IloRangeArray& cons, IloNumVarArray& vars,
    IloCplex& cplex, BPNode& root_node);

// 更新根节点主问题 (添加新列, 复用cplex对象)
bool SolveRootUpdateMP(ProblemParams& params, ProblemData& data,
    IloEnv& env, IloModel& model, IloObjective& obj,
    IloRangeArray& cons, IloNumVarArray& vars,
    IloCplex& cplex, BPNode& node);

// 求解根节点最终主问题并提取解 (复用cplex对象)
bool SolveRootFinalMP(ProblemParams& params, ProblemData& data,
    IloEnv& env, IloModel& model, IloObjective& obj,
    IloRangeArray& cons, IloNumVarArray& vars,
    IloCplex& cplex, BPNode& node);
```

### 2. src/root_node.cpp

- `SolveRootCG`: 创建单一`IloCplex`对象并传递给子函数
- `SolveRootInitMP`: 接收`cplex`引用,只调用`extract()`一次
- `SolveRootUpdateMP`: 接收`cplex`引用,不再创建/销毁
- `SolveRootFinalMP`: 接收`cplex`引用,复用对象

### 3. src/root_node_sub.cpp

- `SolveRootSP2Knapsack`: 修复解提取逻辑,只对宽度匹配的变量调用`getValue()`

## 测试验证

### 测试1: d=0.05算例

```
算例: inst_20251228_083107_d0.05.csv
子板类型: 6种
总需求: 96
结果: 成功完成, 找到3块母板的解
运行时间: 35.841秒
```

### 测试2: d=0.30算例

```
算例: inst_20251228_101847_d0.30.csv
子板类型: 15种
总需求: 196
结果: 成功完成, 找到10块母板的解
运行时间: 51.579秒
迭代次数: 60+次
```

两个测试算例均稳定运行,无崩溃。

## 经验总结

### 1. CPLEX对象生命周期管理

**原则**: CPLEX对象(`IloCplex`)应与其关联的模型(`IloModel`)保持一致的生命周期。

**最佳实践**:
- 在算法主循环外部创建`IloCplex`对象
- 通过引用传递给需要使用的函数
- 添加新变量/约束后不需要重新`extract()`,CPLEX会自动跟踪变化
- 只在算法结束时调用`cplex.end()`释放资源

### 2. CPLEX变量与模型的关系

**原则**: 只能对实际参与模型(目标函数或约束)的变量调用`getValue()`。

**陷阱场景**:
- 创建了变量数组`IloNumVarArray vars`
- 只有部分变量被添加到目标/约束
- 对所有变量调用`getValue()`会崩溃

**检查方法**: 确保`getValue()`调用的变量满足以下条件之一:
- 出现在目标函数表达式中
- 出现在至少一个约束中
- 通过`model.add(var)`显式添加到模型

### 3. 调试CPLEX程序的技巧

1. **使用cerr而非cout/LOG**: cerr是无缓冲的,程序崩溃时不会丢失输出
2. **在每个CPLEX API调用前后添加日志**: 帮助定位具体是哪个API崩溃
3. **检查数组边界和条件逻辑**: CPLEX崩溃往往是由于访问了无效对象
4. **导出LP文件**: 使用`cplex.exportModel()`检查模型是否正确构建

## 附录: 关键代码差异

### SolveRootCG (修复后)

```cpp
void SolveRootCG(ProblemParams& params, ProblemData& data, BPNode& root_node) {
    IloEnv env;
    IloModel model(env);
    IloObjective obj = IloAdd(model, IloMinimize(env));
    IloNumVarArray vars(env);
    IloRangeArray cons(env);

    // 关键修改: 创建单一IloCplex对象并复用
    IloCplex cplex(env);
    cplex.setOut(env.getNullStream());

    root_node.iter_ = 0;

    bool feasible = SolveRootInitMP(params, data, env, model, obj, cons, vars,
                                     cplex, root_node);

    if (feasible) {
        while (true) {
            root_node.iter_++;
            if (root_node.iter_ >= kMaxCgIter) break;

            bool sp1_converged = SolveRootSP1(params, data, root_node);

            if (sp1_converged) {
                bool all_sp2_converged = true;
                for (int j = 0; j < params.num_strip_types_; j++) {
                    bool sp2_converged = SolveRootSP2(params, data, root_node, j);
                    if (!sp2_converged) {
                        all_sp2_converged = false;
                        // 复用cplex对象
                        SolveRootUpdateMP(params, data, env, model, obj, cons, vars,
                                          cplex, root_node);
                    }
                }
                if (all_sp2_converged) break;
            } else {
                SolveRootUpdateMP(params, data, env, model, obj, cons, vars,
                                  cplex, root_node);
            }
        }

        SolveRootFinalMP(params, data, env, model, obj, cons, vars,
                         cplex, root_node);
    }

    // 统一释放资源
    cplex.end();
    obj.end();
    vars.end();
    cons.end();
    model.end();
    env.end();
}
```

### SolveRootSP2Knapsack 解提取 (修复后)

```cpp
// 提取解 - 只对宽度匹配的变量获取值
node.new_x_col_.pattern_.clear();
for (int i = 0; i < num_item_types; i++) {
    int int_val = 0;
    if (data.item_types_[i].width_ <= strip_width) {
        // 只有这些变量在模型中,可以安全调用getValue
        double val = cplex.getValue(vars[i]);
        int_val = (val - (int)val > 0.99999) ? (int)val + 1 : (int)val;
    }
    node.new_x_col_.pattern_.push_back(int_val);
}
```
