// =============================================================================
// main.cpp - 程序入口
// =============================================================================
//
// 功能: 二维下料问题分支定价求解器的主函数
//
// -----------------------------------------------------------------------------
// 程序执行流程
// -----------------------------------------------------------------------------
//
//   +------------------+
//   | 阶段 1: 数据读取 |  读取母板尺寸、子件规格和需求量
//   +--------+---------+
//            |
//   +--------v---------+
//   | 阶段 2: 启发式   |  贪心生成初始可行解, 构建初始模型矩阵
//   +--------+---------+
//            |
//   +--------v---------+
//   | 阶段 3: 列生成   |  迭代求解主问题和子问题, 直至收敛
//   +--------+---------+
//            |
//   +--------v---------+
//   | 阶段 4: 整数检查 |  检查解是否全为整数
//   +--------+---------+
//            |
//      +-----+-----+
//      |           |
//   整数解      分数解
//      |           |
//      v           v
//   [结束]    +----+----+
//            | 阶段 5   |  分支定界搜索整数最优解
//            +---------+
//
// -----------------------------------------------------------------------------
// 使用方法
// -----------------------------------------------------------------------------
//
//   1. 准备输入数据文件 (格式见 input.cpp 注释)
//   2. 修改 input.cpp 中的文件路径
//   3. 编译并运行程序
//   4. 查看控制台输出和日志文件
//
// -----------------------------------------------------------------------------
// 输出说明
// -----------------------------------------------------------------------------
//
//   - 控制台: 实时显示求解进度和关键信息
//   - 日志文件: log_2DBP_YYYYMMDD_HHMMSS.log (详细运行记录)
//   - LP 文件: 导出的 CPLEX 模型文件 (调试用)
//
// =============================================================================

#include "2DBP.h"
#include <filesystem>
#include <chrono>

using namespace std;


// =============================================================================
// main - 主函数
// =============================================================================
int main() {

    // =========================================================================
    // 初始化日志系统
    // =========================================================================
    // 日志系统实现双输出: 同时输出到控制台和日志文件
    // 日志文件名格式: log_2DBP_YYYYMMDD_HHMMSS_mmm.log

    string log_file = "log_2DBP_" + GetCurrentTimestamp();
    Logger logger(log_file);

    cout << "[调试] 日志系统初始化成功\n";
    cout << "[调试] 日志文件: " << logger.getLogFilePath() << "\n";

    // =========================================================================
    // 记录程序开始时间 (用于计算总耗时)
    // =========================================================================
    auto start_time = chrono::high_resolution_clock::now();

    // =========================================================================
    // 输出程序标题
    // =========================================================================
    cout << "\n";
    cout << "============================================================\n";
    cout << "  二维下料问题分支定价求解器 (CS-2D-BP)\n";
    cout << "  2D Cutting Stock Problem - Branch and Price Solver\n";
    cout << "============================================================\n";
    cout << "\n";

    // =========================================================================
    // 初始化全局数据容器
    // =========================================================================
    // All_Lists: 存储所有对象列表 (母板、条带、子件、节点等)
    // All_Values: 存储全局参数和算法状态
    All_Lists Lists;
    All_Values Values;

    // =========================================================================
    // 初始化根节点
    // =========================================================================
    // 根节点是分支定界树的起点, index = 1
    // branch_status = 0 表示初始状态
    Node root_node;
    root_node.index = 1;
    Values.branch_status = 0;

    // =========================================================================
    // 阶段 1: 数据读取与预处理
    // =========================================================================
    // 从文件读取:
    //   - 母板数量和尺寸
    //   - 子件类型数量
    //   - 每种子件的长度、宽度、需求量
    // 预处理:
    //   - 按宽度降序排序子件 (便于贪心放置)
    //   - 初始化母板列表

    cout << "[阶段1] 数据读取与预处理\n";
    cout << "------------------------------------------------------------\n";
    ReadData(Values, Lists);
    cout << "\n";

    // =========================================================================
    // 阶段 2: 原始启发式生成初始解
    // =========================================================================
    // 使用两阶段贪心启发式:
    //   - 第一阶段: 在母板上逐行创建条带
    //   - 第二阶段: 在条带内贪心放置子件
    // 输出:
    //   - 初始切割方案 (存储在 Lists 中)
    //   - 初始模型矩阵 (存储在 root_node 中)

    cout << "[阶段2] 原始启发式生成初始解\n";
    cout << "------------------------------------------------------------\n";
    PrimalHeuristic(Values, Lists, root_node);
    cout << "\n";

    // =========================================================================
    // 阶段 3: 根节点列生成求解
    // =========================================================================
    // 列生成迭代过程:
    //   1. 求解当前受限主问题 (LP 松弛)
    //   2. 提取对偶价格 (影子价格)
    //   3. 求解定价子问题 (SP1: 宽度背包, SP2: 长度背包)
    //   4. 若找到改进列 (检验数 > 0), 添加到主问题, 返回步骤 1
    //   5. 若无改进列, 列生成收敛, 求解最终主问题

    cout << "[阶段3] 根节点列生成求解\n";
    cout << "------------------------------------------------------------\n";
    RootNodeColumnGeneration(Values, Lists, root_node);
    cout << "\n";

    // =========================================================================
    // 阶段 4: 检查整数性并决定是否分支
    // =========================================================================
    // FinishNode 函数:
    //   - 检查所有正值变量是否为整数
    //   - 若全为整数: 更新最优解, 返回 1
    //   - 若存在分数: 记录分支变量, 返回 0
    //
    // search_flag:
    //   - 0 = 需要继续分支
    //   - 1 = 已找到整数解, 无需分支

    cout << "[阶段4] 整数性检查\n";
    cout << "------------------------------------------------------------\n";
    Values.search_flag = FinishNode(Values, Lists, root_node);

    // 将根节点加入节点列表 (用于后续分支操作)
    Lists.all_nodes_list.push_back(root_node);
    Values.root_flag = 1;  // 标记当前在根节点
    cout << "\n";

    // =========================================================================
    // 阶段 5: 分支定界 (若需要)
    // =========================================================================
    // 当根节点解包含分数变量时, 进入分支定界搜索:
    //   - 选择第一个分数变量作为分支变量
    //   - 创建左子节点 (变量 <= floor)
    //   - 创建右子节点 (变量 >= ceil)
    //   - 对子节点执行列生成
    //   - 剪枝不可行或下界不优的节点
    //   - 重复直至找到最优整数解

    if (Values.search_flag == 0) {
        cout << "[阶段5] 分支定界求解\n";
        cout << "------------------------------------------------------------\n";
        Values.branch_status = 1;  // 开始生成左子节点
        BranchAndPriceTree(Values, Lists);
    } else {
        cout << "[阶段5] 无需分支定界 (根节点已获得整数解)\n";
    }
    cout << "\n";

    // =========================================================================
    // 输出求解结果
    // =========================================================================
    cout << "============================================================\n";
    cout << "  求解结果 (Solution Summary)\n";
    cout << "============================================================\n";

    // 计算总耗时
    auto end_time = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::milliseconds>(end_time - start_time);
    double seconds = duration.count() / 1000.0;

    // 输出关键指标
    cout << fixed << setprecision(2);
    cout << "  最优目标值 (母板数): " << Values.optimal_LB << "\n";
    cout << "  总耗时: " << seconds << " 秒\n";
    cout << "  分支节点数: " << Values.node_num << "\n";
    cout.unsetf(ios::fixed);

    cout << "============================================================\n";
    cout << "\n";
    cout << "[完成] 程序执行结束\n";

    return 0;
}
