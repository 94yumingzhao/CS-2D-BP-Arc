// =============================================================================
// 2DBP.h - 二维下料问题分支定价求解器 主头文件
// =============================================================================
//
// 项目名称: CS-2D-BP (2D Cutting Stock Problem - Branch and Price)
// 项目描述: 采用两阶段切割的二维下料问题分支定价算法实现
//
// -----------------------------------------------------------------------------
// 一、问题背景
// -----------------------------------------------------------------------------
//
// 二维下料问题 (2D Cutting Stock Problem) 是工业生产中的经典优化问题:
//   - 给定: 若干相同尺寸的母板 (Stock)
//   - 给定: 多种不同规格的子件 (Item), 每种有特定需求量
//   - 目标: 用最少的母板数量切割出所有需求的子件
//
// 本项目采用两阶段切割 (Two-Stage Cutting) 策略:
//   - 第一阶段: 沿宽度方向 (Y轴) 将母板切割成若干条带 (Strip)
//   - 第二阶段: 沿长度方向 (X轴) 将每个条带切割成子件
//
// 切割示意图:
//
//   母板 (Stock)                    条带 (Strip)           子件 (Item)
//   +-----------------------+       +-------+-------+      +---+---+---+
//   |                       |  -->  | Strip1        |  --> | A | B | C |
//   |-----------------------|       +-------+-------+      +---+---+---+
//   |                       |  -->  | Strip2        |
//   |-----------------------|       +-------+-------+
//   |                       |  -->  | Strip3        |
//   +-----------------------+       +---------------+
//         第一阶段切割                 第二阶段切割
//       (沿宽度方向切)                (沿长度方向切)
//
// -----------------------------------------------------------------------------
// 二、算法原理
// -----------------------------------------------------------------------------
//
// 本项目使用分支定价 (Branch and Price) 算法求解:
//
// 1. 列生成 (Column Generation):
//    - 主问题 (Master Problem): 选择切割模式的组合, 最小化母板使用数量
//    - 子问题 (Sub Problem): 寻找新的有价值的切割模式 (定价问题)
//    - 迭代: 主问题 -> 对偶价格 -> 子问题 -> 新列 -> 更新主问题 -> ...
//
// 2. 分支定界 (Branch and Bound):
//    - 当列生成收敛后, 若存在非整数解, 则进行分支
//    - 对非整数变量进行向下/向上取整分支
//    - 构建搜索树, 通过剪枝加速求解
//
// 算法流程图:
//
//   +------------------+
//   | 读取问题数据     |
//   +--------+---------+
//            |
//   +--------v---------+
//   | 启发式生成初始解 |  <-- 贪心算法生成初始切割模式
//   +--------+---------+
//            |
//   +--------v---------+
//   | 根节点列生成求解 |  <-- 迭代求解 LP 松弛问题
//   +--------+---------+
//            |
//   +--------v---------+
//   | 检查整数性       |
//   +--------+---------+
//            |
//      +-----+-----+
//      |           |
//   整数解      分数解
//      |           |
//   +--v--+    +---v--------------+
//   | 结束|    | 分支定界搜索     |
//   +-----+    +------------------+
//
// -----------------------------------------------------------------------------
// 三、主问题数学模型
// -----------------------------------------------------------------------------
//
// 决策变量:
//   Y_k: 第 k 种母板切割模式的使用次数
//   X_p: 第 p 种条带切割模式的使用次数
//
// 目标函数:
//   min sum(Y_k)  -- 最小化母板使用数量
//
// 约束矩阵结构:
//
//                  K 列 (Y变量)          P 列 (X变量)
//                [母板切割模式]       [条带切割模式]
//              +------------------+------------------+
//   J 行       |        C         |        D         |  >= 0    (条带平衡约束)
//   (条带)     |   c_jk >= 0      |   d_jp = -1/0    |
//              +------------------+------------------+
//   N 行       |        0         |        B         |  >= d_i  (子件需求约束)
//   (子件)     |     全为 0       |   b_ip >= 0      |
//              +------------------+------------------+
//
// 矩阵含义:
//   C[j][k] = 母板模式 k 产出的条带类型 j 的数量
//   D[j][p] = -1 如果条带模式 p 属于条带类型 j, 否则为 0
//   B[i][p] = 条带模式 p 产出的子件类型 i 的数量
//
// -----------------------------------------------------------------------------
// 四、子问题数学模型
// -----------------------------------------------------------------------------
//
// 第一阶段子问题 SP1 (宽度方向背包问题):
//   max  sum_j(lambda_j * G_j)           -- 最大化对偶价格和
//   s.t. sum_j(w_j * G_j) <= W           -- 宽度约束
//        G_j >= 0, 整数                  -- 整数约束
//
//   其中:
//     lambda_j = 条带类型 j 的对偶价格
//     w_j = 条带类型 j 的宽度
//     W = 母板宽度
//
// 第二阶段子问题 SP2 (长度方向背包问题):
//   max  sum_i(mu_i * D_i)               -- 最大化对偶价格和
//   s.t. sum_i(l_i * D_i) <= L           -- 长度约束
//        w_i <= w_j                       -- 宽度可行性
//        D_i >= 0, 整数                  -- 整数约束
//
//   其中:
//     mu_i = 子件类型 i 的对偶价格
//     l_i = 子件类型 i 的长度
//     L = 母板长度 (即条带长度)
//
// -----------------------------------------------------------------------------
// 五、缩写说明
// -----------------------------------------------------------------------------
//
//   CG   - Column Generation (列生成)
//   MP   - Master Problem (主问题)
//   SP   - Sub Problem (子问题)
//   SP1  - 第一阶段子问题 (宽度背包)
//   SP2  - 第二阶段子问题 (长度背包)
//   LB   - Lower Bound (下界)
//   UB   - Upper Bound (上界)
//   RC   - Reduced Cost (检验数)
//   var  - variable (变量)
//   con  - constraint (约束)
//   col  - column (列)
//   row  - row (行)
//   val  - value (值)
//   soln - solution (解)
//   fsb  - feasible (可行)
//   int  - integer (整数)
//   idx  - index (索引)
//   num  - number (数量)
//   pos  - position (位置)
//
// =============================================================================

#ifndef CS_2D_BP_H_
#define CS_2D_BP_H_

// -----------------------------------------------------------------------------
// 标准库头文件
// -----------------------------------------------------------------------------
#include <vector>       // 动态数组
#include <queue>        // 队列
#include <iostream>     // 标准输入输出
#include <fstream>      // 文件输入输出
#include <sstream>      // 字符串流
#include <string>       // 字符串
#include <map>          // 映射容器
#include <array>        // 固定大小数组
#include <algorithm>    // 算法库
#include <cstdio>       // C 风格输入输出
#include <cmath>        // 数学函数 (floor, ceil)
#include <iomanip>      // 输出格式控制

// -----------------------------------------------------------------------------
// CPLEX 优化求解器头文件
// -----------------------------------------------------------------------------
#include <ilcplex/ilocplex.h>

// -----------------------------------------------------------------------------
// 项目内部头文件
// -----------------------------------------------------------------------------
#include "logger.h"

using namespace std;

// =============================================================================
// 全局常量定义
// =============================================================================

// 检验数阈值 (Reduced Cost Epsilon)
// 用于判断是否找到改进列: 当 SP 目标值 > 1 + RC_EPS 时, 说明找到了改进列
// 设置一个小的正数是为了避免浮点数精度问题导致的误判
#define RC_EPS 1.0e-6


// =============================================================================
// =============================================================================
//
//                           数 据 结 构 定 义
//
// =============================================================================
// =============================================================================


// =============================================================================
// 子件类型结构体 (One_Item_Type)
// =============================================================================
//
// 用途: 存储一种子件类型的基本规格信息
//
// 使用场景:
//   1. 读取输入数据时, 记录每种子件的规格和需求量
//   2. 构建约束矩阵时, 作为子件需求约束的右端项
//   3. 在条带内统计各类型子件的数量
//
// 示例:
//   子件类型 1: 长度=100, 宽度=50, 需求量=20
//   子件类型 2: 长度=80,  宽度=40, 需求量=15
//
// =============================================================================
struct One_Item_Type {
    // -------------------------------------------------------------------------
    // 基本标识
    // -------------------------------------------------------------------------
    int item_type_idx = -1;       // 子件类型索引 (从 1 开始编号)
                                  // -1 表示未初始化

    // -------------------------------------------------------------------------
    // 规格参数
    // -------------------------------------------------------------------------
    int length = -1;              // 子件长度 (沿 X 轴方向)
    int width = -1;               // 子件宽度 (沿 Y 轴方向)
                                  // 注意: 条带的宽度由其首个子件的宽度决定

    // -------------------------------------------------------------------------
    // 需求信息
    // -------------------------------------------------------------------------
    double demand = -1;           // 需求量 (需要切割出的数量)
                                  // 使用 double 是为了兼容 CPLEX 约束

    // -------------------------------------------------------------------------
    // 计数器 (用于模式统计)
    // -------------------------------------------------------------------------
    int this_item_type_num = 0;   // 当前切割模式中该类型子件的数量
                                  // 用于: 1) 统计条带内各类型子件数量
                                  //       2) 判断两个切割模式是否相同
};


// =============================================================================
// 条带类型结构体 (One_Strip_Type)
// =============================================================================
//
// 用途: 存储一种条带类型的基本规格信息
//
// 关键概念:
//   - 条带类型由其宽度唯一确定
//   - 条带宽度 = 首个子件的宽度
//   - 条带长度 = 母板长度 (固定值)
//
// 使用场景:
//   1. 第一阶段子问题 (SP1): 作为背包问题中的物品
//   2. 主问题约束矩阵: 条带平衡约束的索引
//   3. 判断子件是否可以放入某类型条带
//
// =============================================================================
struct One_Strip_Type {
    // -------------------------------------------------------------------------
    // 基本标识
    // -------------------------------------------------------------------------
    int strip_type_idx = -1;      // 条带类型索引 (从 1 开始编号)
                                  // 通常与相同宽度的子件类型索引一致

    // -------------------------------------------------------------------------
    // 规格参数
    // -------------------------------------------------------------------------
    int width = -1;               // 条带宽度 (沿 Y 轴方向)
                                  // 由首个子件的宽度决定
    int length = -1;              // 条带长度 (沿 X 轴方向)
                                  // 固定等于母板长度

    // -------------------------------------------------------------------------
    // 计数器 (用于模式统计)
    // -------------------------------------------------------------------------
    int this_strip_type_num = 0;  // 当前母板模式中该类型条带的数量
                                  // 用于: 1) 构建主问题 C 矩阵
                                  //       2) 判断两个母板模式是否相同
};


// =============================================================================
// 母板类型结构体 (One_Stock_Type)
// =============================================================================
//
// 用途: 存储一种母板类型的基本信息
//
// 说明:
//   本项目假设所有母板尺寸相同, 因此只有一种母板类型
//   保留此结构是为了未来扩展到多种母板尺寸的场景
//
// =============================================================================
struct One_Stock_Type {
    int stock_type_idx = -1;      // 母板类型索引 (当前版本固定为 0)
    int this_stock_type_num = 0;  // 该类型母板的使用数量
};


// =============================================================================
// 单个子件结构体 (One_Item)
// =============================================================================
//
// 用途: 存储单个子件实例的完整信息 (包括几何属性和位置信息)
//
// 关键概念:
//   - 子件是切割的最终产品
//   - 每个子件属于某个子件类型
//   - 在切割方案中, 子件被放置在特定的条带内
//
// 坐标系说明:
//   - 原点 (0, 0) 位于母板左上角
//   - X 轴向右为正 (长度方向)
//   - Y 轴向下为正 (宽度方向)
//
//   (0,0) -----> X (长度方向)
//      |
//      |
//      v
//      Y (宽度方向)
//
// =============================================================================
struct One_Item {
    // -------------------------------------------------------------------------
    // 标识信息
    // -------------------------------------------------------------------------
    int item_idx = -1;            // 子件实例索引 (全局唯一, 从 1 开始)
    int item_type_idx = -1;       // 所属子件类型索引

    // -------------------------------------------------------------------------
    // 规格参数
    // -------------------------------------------------------------------------
    int length = -1;              // 子件长度 (沿 X 轴)
    int width = -1;               // 子件宽度 (沿 Y 轴)
    int area = -1;                // 子件面积 = length * width
    int demand = -1;              // 该类型的需求量 (冗余存储, 方便访问)

    // -------------------------------------------------------------------------
    // 位置信息
    // -------------------------------------------------------------------------
    int pos_x = -1;               // 左上角 X 坐标 (相对于母板原点)
    int pos_y = -1;               // 左上角 Y 坐标 (相对于母板原点)

    // -------------------------------------------------------------------------
    // 归属信息
    // -------------------------------------------------------------------------
    int strip_idx = -1;           // 所属条带索引
    int stock_idx = -1;           // 所属母板索引

    // -------------------------------------------------------------------------
    // 状态标志
    // -------------------------------------------------------------------------
    int occupied_flag = 0;        // 分配标志:
                                  //   0 = 未分配 (待放置)
                                  //   1 = 已分配 (已放入某条带)

    // -------------------------------------------------------------------------
    // 成本信息 (用于成本计算)
    // -------------------------------------------------------------------------
    int cutting_distance = -1;    // 切割距离 (刀具行走距离)
    int material_cutting_loss = -1; // 切割损耗 = cutting_distance * unit_cut_loss
};


// =============================================================================
// 单个条带结构体 (One_Strip)
// =============================================================================
//
// 用途: 存储单个条带的完整信息 (包括其内部的子件列表)
//
// 关键概念:
//   - 条带是母板经第一阶段切割后的中间产品
//   - 条带长度 = 母板长度 (固定)
//   - 条带宽度 = 首个子件的宽度
//   - 每个条带包含若干子件
//
// 结构示意图:
//
//   条带 (长度 = 母板长度)
//   +-------+-------+-------+-------+-----------+
//   | Item1 | Item2 | Item3 | Item4 |  废料     |
//   +-------+-------+-------+-------+-----------+
//   <--------- 条带长度 (= 母板长度) ----------->
//
// =============================================================================
struct One_Strip {
    // -------------------------------------------------------------------------
    // 标识信息
    // -------------------------------------------------------------------------
    int strip_idx = -1;           // 条带实例索引 (全局唯一)
    int strip_type_idx = -1;      // 条带类型索引 (由首个子件宽度决定)
    int pattern = -1;             // 切割模式编号 (具有相同子件组合的条带共享同一模式)

    // -------------------------------------------------------------------------
    // 包含的子件
    // -------------------------------------------------------------------------
    vector<One_Item> items_list;            // 该条带内的所有子件列表
    vector<One_Item_Type> item_types_list;  // 各子件类型的统计信息
                                            // 用于判断两个条带是否为相同模式

    // -------------------------------------------------------------------------
    // 规格参数
    // -------------------------------------------------------------------------
    int length = -1;              // 条带长度 (= 母板长度)
    int width = -1;               // 条带宽度 (= 首个子件宽度)
    int area = -1;                // 条带面积 = length * width

    // -------------------------------------------------------------------------
    // 位置信息
    // -------------------------------------------------------------------------
    int pos_x = -1;               // 左上角 X 坐标 (相对于母板原点)
    int pos_y = -1;               // 左上角 Y 坐标 (相对于母板原点)

    // -------------------------------------------------------------------------
    // 归属信息
    // -------------------------------------------------------------------------
    int stock_idx = -1;           // 所属母板索引

    // -------------------------------------------------------------------------
    // 成本信息
    // -------------------------------------------------------------------------
    int cutting_distance = -1;    // 切割距离
    int material_cutting_loss = -1; // 切割损耗
    int wasted_area = -1;         // 废料面积 = 条带面积 - 子件面积之和
    int material_area_loss = -1;  // 面积损耗 = wasted_area * unit_area_loss
};


// =============================================================================
// 单个母板结构体 (One_Stock)
// =============================================================================
//
// 用途: 存储单个母板的完整信息 (包括其内部的条带列表)
//
// 关键概念:
//   - 母板是切割的原材料
//   - 所有母板尺寸相同 (本项目假设)
//   - 每个母板包含若干条带
//   - 母板模式 = 条带类型的组合
//
// 结构示意图:
//
//   母板 (长度 L x 宽度 W)
//   +---------------------------------------+
//   |              Strip 1                  |
//   +---------------------------------------+
//   |              Strip 2                  |
//   +---------------------------------------+
//   |              Strip 3                  |
//   +---------------------------------------+
//   |              废料                     |
//   +---------------------------------------+
//
// =============================================================================
struct One_Stock {
    // -------------------------------------------------------------------------
    // 标识信息
    // -------------------------------------------------------------------------
    int stock_idx = -1;           // 母板实例索引 (全局唯一)
    int stock_type_idx = 0;       // 母板类型索引 (当前版本固定为 0)
    int pattern = -1;             // 切割模式编号 (具有相同条带组合的母板共享同一模式)

    // -------------------------------------------------------------------------
    // 包含的条带
    // -------------------------------------------------------------------------
    vector<One_Strip> strips_list;            // 该母板内的所有条带列表
    vector<One_Strip_Type> strip_types_list;  // 各条带类型的统计信息
                                              // 用于: 1) 构建主问题 C 矩阵
                                              //       2) 判断两个母板是否为相同模式

    // -------------------------------------------------------------------------
    // 规格参数
    // -------------------------------------------------------------------------
    int length = -1;              // 母板长度 (沿 X 轴)
    int width = -1;               // 母板宽度 (沿 Y 轴)
    int area = -1;                // 母板面积 = length * width

    // -------------------------------------------------------------------------
    // 位置信息 (用于可视化)
    // -------------------------------------------------------------------------
    int pos_x = -1;               // 左上角 X 坐标 (通常为 0)
    int pos_y = -1;               // 左上角 Y 坐标 (通常为 0)

    // -------------------------------------------------------------------------
    // 成本信息
    // -------------------------------------------------------------------------
    int cutting_distance = -1;    // 总切割距离
    int material_cutting_loss = -1; // 总切割损耗
    int wasted_area = -1;         // 总废料面积
    int material_area_loss = -1;  // 总面积损耗
};


// =============================================================================
// 分支定界节点结构体 (Node)
// =============================================================================
//
// 用途: 存储分支定价树中单个节点的完整状态
//
// 关键概念:
//   - 节点代表一个受限的优化问题
//   - 根节点 (index=1) 是原始的 LP 松弛问题
//   - 子节点通过对某个变量添加整数约束产生
//   - 每个节点维护自己的模型矩阵和解信息
//
// 分支树结构示意:
//
//                     [根节点 index=1]
//                     LB = 3.5, x1 = 1.5
//                    /                  \
//           x1 <= 1 /                    \ x1 >= 2
//                  /                      \
//         [节点 index=2]              [节点 index=3]
//         LB = 4.0, 整数解             LB = 3.8, x2 = 0.7
//                                     /                  \
//                            x2 <= 0 /                    \ x2 >= 1
//                                   /                      \
//                          [节点 index=4]              [节点 index=5]
//                          LB = 4.2                    LB = 不可行 (剪枝)
//
// =============================================================================
struct Node {
    // =========================================================================
    // 节点标识
    // =========================================================================
    int index = -1;               // 节点索引 (根节点为 1, 子节点依次递增)

    // =========================================================================
    // 父节点信息
    // =========================================================================
    int parent_index = -1;                // 父节点索引 (-1 表示根节点)
    int parent_branching_flag = -1;       // 父节点的分支方向:
                                          //   1 = 本节点是左子节点 (floor)
                                          //   2 = 本节点是右子节点 (ceil)
    double parent_var_to_branch_val = -1; // 父节点分支变量的原始值

    // =========================================================================
    // 节点状态
    // =========================================================================
    double LB = -1;               // 该节点的下界值 (LP 松弛最优值)
                                  // 对于最小化问题, 子节点的 LB >= 父节点的 LB

    int node_branched_flag = -1;  // 分支标志:
                                  //   1 = 已生成左子节点
                                  //   2 = 已生成右子节点
                                  //   -1 = 未分支

    int node_pruned_flag = -1;    // 剪枝标志:
                                  //   0 = 未剪枝 (活跃节点)
                                  //   1 = 已剪枝 (不再探索)
                                  // 剪枝条件: 不可行 或 LB >= 当前最优整数解

    // =========================================================================
    // 分支变量信息 (当前节点将要分支的变量)
    // =========================================================================
    int var_to_branch_idx = -1;      // 待分支变量的列索引 (0-based)
    double var_to_branch_soln = -1;  // 待分支变量的解值 (分数值)
    double var_to_branch_floor = -1; // 向下取整值 = floor(var_to_branch_soln)
    double var_to_branch_ceil = -1;  // 向上取整值 = ceil(var_to_branch_soln)
    double var_to_branch_final = -1; // 最终确定的整数值 (左节点=floor, 右节点=ceil)

    // =========================================================================
    // 分支历史 (从根节点到当前节点的路径)
    // =========================================================================
    // 这三个列表记录了从根节点到当前节点所有已分支变量的信息
    // 用于构建子节点时继承父节点的分支约束

    vector<int> branched_idx_list;      // 所有已分支变量的列索引
    vector<double> branched_int_list;   // 所有已分支变量的整数值 (固定值)
    vector<double> branched_solns_ist;  // 所有已分支变量的原始解值 (分支前的分数值)
                                        // 注: "ist" 是 "list" 的笔误, 保持兼容

    // =========================================================================
    // 解信息
    // =========================================================================
    vector<double> all_solns_val_list;  // 所有变量的最终解值 (包含零值)
                                        // 索引顺序: [Y_1, ..., Y_K, X_1, ..., X_P]

    // =========================================================================
    // 列生成迭代数据
    // =========================================================================
    int iter = -1;                          // 当前迭代次数 (从 0 开始)

    vector<vector<double>> model_matrix;    // 当前主问题的系数矩阵 (列主序存储)
                                            // model_matrix[col][row] = 第 col 列第 row 行的系数
                                            // 列顺序: [Y列, X列]
                                            // 行顺序: [条带约束, 子件约束]

    vector<double> dual_prices_list;        // 主问题约束的对偶价格 (影子价格)
                                            // 索引顺序: [lambda_1, ..., lambda_J, mu_1, ..., mu_N]
                                            // 用于子问题的目标函数系数

    // =========================================================================
    // 切割模式存储
    // =========================================================================
    // Y_patterns_list 和 X_patterns_list 存储模式的详细信息
    // Y_cols_list 和 X_cols_list 存储模式的系数列 (用于主问题)

    vector<One_Stock> Y_patterns_list;  // 第一阶段模式详细信息 (母板切割方案)
    vector<One_Strip> X_patterns_list;  // 第二阶段模式详细信息 (条带切割方案)

    vector<vector<double>> Y_cols_list; // 第一阶段模式的系数列
                                        // Y_cols_list[k][row] = 模式 k 在第 row 行的系数
    vector<vector<double>> X_cols_list; // 第二阶段模式的系数列
                                        // X_cols_list[p][row] = 模式 p 在第 row 行的系数

    // =========================================================================
    // 新生成的列 (子问题求解结果)
    // =========================================================================
    vector<double> new_Y_col;                 // 新的第一阶段模式列 (SP1 的解)
    vector<vector<double>> new_X_cols_list;   // 新的第二阶段模式列集合 (SP2 的解)
                                              // 可能有多个改进列

    // =========================================================================
    // 子问题信息
    // =========================================================================
    double SP2_obj_val = -1;          // 第二阶段子问题的最优目标值
    vector<double> SP2_solns_list;    // 第二阶段子问题的最优解
    int Y_col_flag = -1;              // 新列类型标志:
                                      //   1 = 新增 Y 列 (SP1 找到改进列)
                                      //   0 = 新增 X 列 (SP2 找到改进列)
};


// =============================================================================
// 全局参数结构体 (All_Values)
// =============================================================================
//
// 用途: 存储问题的全局参数和算法运行状态
//
// 包含内容:
//   1. 问题规模参数 (子件数、母板数等)
//   2. 母板尺寸参数
//   3. 成本参数
//   4. 算法状态标志
//   5. 最优解信息
//
// =============================================================================
struct All_Values {
    // =========================================================================
    // 算法控制标志
    // =========================================================================
    bool Finish;                  // 启发式完成标志:
                                  //   true = 所有子件已分配
                                  //   false = 仍有未分配子件

    // =========================================================================
    // 问题规模参数
    // =========================================================================
    int item_types_num = -1;      // 子件类型数量 (N)
    int strip_types_num = -1;     // 条带类型数量 (J)
                                  // 通常 J = N (每种子件宽度对应一种条带类型)
    int stock_types_num = -1;     // 母板类型数量 (当前版本固定为 1)

    int items_num = -1;           // 子件总数 (所有类型需求量之和)
    int strips_num = -1;          // 条带总数
    int stocks_num = -1;          // 可用母板数量 (上界)

    // =========================================================================
    // 母板尺寸参数
    // =========================================================================
    int stock_length = -1;        // 母板长度 (L, 沿 X 轴)
    int stock_width = -1;         // 母板宽度 (W, 沿 Y 轴)

    // =========================================================================
    // 成本参数
    // =========================================================================
    int unit_cut_loss = -1;       // 单位切割损耗 (每单位切割距离的成本)
    int unit_area_loss = -1;      // 单位面积损耗 (每单位废料面积的成本)
    int final_cut_loss = -1;      // 最终方案的总切割损耗
    int final_area_loss = -1;     // 最终方案的总面积损耗

    // =========================================================================
    // 分支定界树参数
    // =========================================================================
    int level_num = -1;           // 分支树当前层数 (深度)
    int node_num = -1;            // 已生成的节点总数

    // =========================================================================
    // 最优解信息
    // =========================================================================
    double optimal_LB = -1;       // 当前最优下界 (已找到的最优整数解值)
                                  // -1 表示尚未找到整数解

    // =========================================================================
    // 分支状态标志
    // =========================================================================
    // branch_status: 控制下一步分支操作
    //   1 = 生成左子节点 (对分支变量取 floor)
    //   2 = 生成右子节点 (对分支变量取 ceil)
    //   3 = 搜索其他未探索的节点
    int branch_status = -1;

    // search_flag: 控制搜索策略
    //   0 = 继续分支当前节点 (当前节点解包含分数)
    //   1 = 停止分支, 搜索其他节点 (当前节点解全为整数或已剪枝)
    int search_flag = -1;

    // fathom_flag: 深入探索方向
    //   1 = 深入左子节点
    //   2 = 深入右子节点
    //   -1 = 不确定
    int fathom_flag = -1;

    // root_flag: 根节点标志
    //   1 = 当前父节点是根节点
    //   0 = 当前父节点不是根节点
    int root_flag = -1;
};


// =============================================================================
// 全局列表结构体 (All_Lists)
// =============================================================================
//
// 用途: 存储所有数据对象的列表
//
// 设计思想:
//   将所有全局数据集中管理, 便于在函数间传递
//   避免使用全局变量, 提高代码可维护性
//
// =============================================================================
struct All_Lists {
    // =========================================================================
    // 分支定界树节点
    // =========================================================================
    vector<Node> all_nodes_list;              // 所有分支节点的列表
                                              // 包括根节点和所有子节点

    // =========================================================================
    // 切割对象列表
    // =========================================================================
    vector<One_Stock> all_stocks_list;        // 所有可用母板的列表 (初始库存)
    vector<One_Strip> all_strips_list;        // 所有已生成条带的列表
    vector<One_Item> all_items_list;          // 所有子件的列表 (按需求量展开)

    // =========================================================================
    // 类型列表
    // =========================================================================
    vector<One_Strip_Type> all_strip_types_list;  // 所有条带类型的列表
    vector<One_Item_Type> all_item_types_list;    // 所有子件类型的列表

    // =========================================================================
    // 已使用/已分配列表
    // =========================================================================
    vector<One_Stock> occupied_stocks_list;   // 已使用的母板列表 (切割方案)
    vector<One_Item> occupied_items_list;     // 已分配的子件列表
};


// =============================================================================
// =============================================================================
//
//                           函 数 声 明
//
// =============================================================================
// =============================================================================


// =============================================================================
// 工具函数
// =============================================================================

// -----------------------------------------------------------------------------
// SplitString - 字符串分割函数
// -----------------------------------------------------------------------------
// 功能: 按指定分隔符分割字符串
// 参数:
//   s - 待分割的字符串
//   v - 输出: 分割后的子字符串列表
//   c - 分隔符
// 示例:
//   SplitString("100\t50\t20", v, "\t") -> v = ["100", "50", "20"]
// -----------------------------------------------------------------------------
void SplitString(const string& s, vector<string>& v, const string& c);


// =============================================================================
// 数据读取函数
// =============================================================================

// -----------------------------------------------------------------------------
// ReadData - 读取问题数据
// -----------------------------------------------------------------------------
// 功能: 从文件读取二维下料问题的输入数据
// 参数:
//   Values - 输出: 全局参数 (母板尺寸、子件数量等)
//   Lists  - 输出: 全局列表 (子件列表、母板列表等)
// 文件格式:
//   第 1 行: 母板数量
//   第 2 行: 子件类型数量
//   第 3 行: 母板长度 <TAB> 母板宽度
//   第 4 行起: 子件长度 <TAB> 子件宽度 <TAB> 需求量 <TAB> 类型索引
// -----------------------------------------------------------------------------
void ReadData(All_Values& Values, All_Lists& Lists);


// =============================================================================
// 启发式求解函数
// =============================================================================

// -----------------------------------------------------------------------------
// PrimalHeuristic - 原始启发式生成初始解
// -----------------------------------------------------------------------------
// 功能: 使用贪心启发式生成初始可行解和模型矩阵
// 算法:
//   1. 按宽度降序处理子件
//   2. 逐个母板进行切割, 直到所有子件分配完毕
//   3. 每个条带内贪心放置可行子件
//   4. 根据切割方案构建初始模型矩阵
// 参数:
//   Values    - 全局参数
//   Lists     - 全局列表
//   root_node - 输出: 根节点 (存储初始模式和矩阵)
// -----------------------------------------------------------------------------
void PrimalHeuristic(All_Values& Values, All_Lists& Lists, Node& root_node);


// =============================================================================
// 列生成求解函数
// =============================================================================

// -----------------------------------------------------------------------------
// RootNodeColumnGeneration - 根节点列生成主循环
// -----------------------------------------------------------------------------
// 功能: 在根节点执行完整的列生成过程
// 算法流程:
//   1. 构建并求解初始主问题
//   2. 循环:
//      a. 提取对偶价格
//      b. 求解子问题 (SP1, SP2)
//      c. 若找到改进列, 添加到主问题并重新求解
//      d. 否则, 列生成收敛, 退出循环
//   3. 求解最终主问题, 提取解
// 参数:
//   Values    - 全局参数
//   Lists     - 全局列表
//   root_node - 输入/输出: 根节点
// -----------------------------------------------------------------------------
void RootNodeColumnGeneration(All_Values& Values, All_Lists& Lists, Node& root_node);

// -----------------------------------------------------------------------------
// SolveRootNodeFirstMasterProblem - 求解根节点初始主问题
// -----------------------------------------------------------------------------
// 功能: 构建并求解根节点的初始受限主问题
// 参数:
//   Values       - 全局参数
//   Lists        - 全局列表
//   Env_MP       - CPLEX 环境对象
//   Model_MP     - CPLEX 模型对象
//   Obj_MP       - 目标函数对象
//   Cons_List_MP - 约束数组
//   Vars_List_MP - 变量数组
//   root_node    - 根节点
// 返回值:
//   true  = 主问题可行
//   false = 主问题不可行 (理论上不应发生)
// -----------------------------------------------------------------------------
bool SolveRootNodeFirstMasterProblem(
    All_Values& Values,
    All_Lists& Lists,
    IloEnv& Env_MP,
    IloModel& Model_MP,
    IloObjective& Obj_MP,
    IloRangeArray& Cons_List_MP,
    IloNumVarArray& Vars_List_MP,
    Node& root_node);


// =============================================================================
// 子问题求解函数
// =============================================================================

// -----------------------------------------------------------------------------
// SolveStageOneSubProblem - 求解第一阶段子问题 (宽度背包)
// -----------------------------------------------------------------------------
// 功能: 求解 SP1, 寻找新的母板切割模式
// 数学模型:
//   max  sum_j(lambda_j * G_j)
//   s.t. sum_j(w_j * G_j) <= W
//        G_j >= 0, 整数
// 参数:
//   Values    - 全局参数
//   Lists     - 全局列表
//   this_node - 当前节点
// 返回值:
//   0 = 未找到改进列 (列生成收敛)
//   1 = 找到改进列 (需更新主问题)
// -----------------------------------------------------------------------------
int SolveStageOneSubProblem(All_Values& Values, All_Lists& Lists, Node& this_node);

// -----------------------------------------------------------------------------
// SolveStageTwoSubProblem - 求解第二阶段子问题 (长度背包)
// -----------------------------------------------------------------------------
// 功能: 求解 SP2, 寻找新的条带切割模式
// 数学模型:
//   max  sum_i(mu_i * D_i)
//   s.t. sum_i(l_i * D_i) <= L
//        w_i <= w_j (只考虑宽度可行的子件)
//        D_i >= 0, 整数
// 参数:
//   Values         - 全局参数
//   Lists          - 全局列表
//   this_node      - 当前节点
//   strip_type_idx - 条带类型索引 (决定宽度约束)
// 返回值:
//   0 = 未找到改进列
//   1 = 找到改进列
// -----------------------------------------------------------------------------
int SolveStageTwoSubProblem(All_Values& Values, All_Lists& Lists, Node& this_node, int strip_type_idx);


// =============================================================================
// 主问题更新函数
// =============================================================================

// -----------------------------------------------------------------------------
// SolveUpdateMasterProblem - 添加新列并重新求解主问题
// -----------------------------------------------------------------------------
// 功能: 将子问题找到的新列添加到主问题, 并重新求解
// 参数:
//   Values   - 全局参数
//   Lists    - 全局列表
//   Env_MP   - CPLEX 环境对象
//   Model_MP - CPLEX 模型对象
//   Obj_MP   - 目标函数对象
//   Cons_MP  - 约束数组
//   Vars_MP  - 变量数组
//   this_node - 当前节点
// -----------------------------------------------------------------------------
void SolveUpdateMasterProblem(
    All_Values& Values,
    All_Lists& Lists,
    IloEnv& Env_MP,
    IloModel& Model_MP,
    IloObjective& Obj_MP,
    IloRangeArray& Cons_MP,
    IloNumVarArray& Vars_MP,
    Node& this_node);

// -----------------------------------------------------------------------------
// SolveFinalMasterProblem - 求解列生成收敛后的最终主问题
// -----------------------------------------------------------------------------
// 功能: 列生成收敛后, 求解最终主问题并提取最优解
// 参数:
//   Values       - 全局参数
//   Lists        - 全局列表
//   Env_MP       - CPLEX 环境对象
//   Model_MP     - CPLEX 模型对象
//   Obj_MP       - 目标函数对象
//   Cons_List_MP - 约束数组
//   Vars_List_MP - 变量数组
//   this_node    - 当前节点
// -----------------------------------------------------------------------------
void SolveFinalMasterProblem(
    All_Values& Values,
    All_Lists& Lists,
    IloEnv& Env_MP,
    IloModel& Model_MP,
    IloObjective& Obj_MP,
    IloRangeArray& Cons_List_MP,
    IloNumVarArray& Vars_List_MP,
    Node& this_node);


// =============================================================================
// 节点处理函数
// =============================================================================

// -----------------------------------------------------------------------------
// FinishNode - 完成节点处理
// -----------------------------------------------------------------------------
// 功能: 检查节点解的整数性, 更新最优解, 决定下一步操作
// 算法:
//   1. 调用 ChooseVarToBranch 检查整数性
//   2. 若全为整数:
//      - 更新最优下界 (若更优)
//      - 标记节点为叶节点
//      - 返回 1 (搜索其他节点)
//   3. 若存在分数解:
//      - 记录分支变量
//      - 返回 0 (继续分支)
// 参数:
//   Values    - 全局参数
//   Lists     - 全局列表
//   this_node - 当前节点
// 返回值:
//   0 = 存在分数解, 需要继续分支
//   1 = 全为整数解或已剪枝, 搜索其他节点
// -----------------------------------------------------------------------------
int FinishNode(All_Values& Values, All_Lists& Lists, Node& this_node);

// -----------------------------------------------------------------------------
// ChooseVarToBranch - 选择分支变量
// -----------------------------------------------------------------------------
// 功能: 遍历所有正值变量, 找到第一个非整数变量作为分支变量
// 策略: First Fractional (最简单的分支变量选择策略)
// 参数:
//   Values    - 全局参数
//   Lists     - 全局列表
//   this_node - 当前节点 (更新 var_to_branch_* 字段)
// 返回值:
//   0 = 存在非整数解 (已记录分支变量信息)
//   1 = 全为整数解
// -----------------------------------------------------------------------------
int ChooseVarToBranch(All_Values& Values, All_Lists& Lists, Node& this_node);


// =============================================================================
// 分支定界函数
// =============================================================================

// -----------------------------------------------------------------------------
// BranchAndPriceTree - 分支定价搜索树主循环
// -----------------------------------------------------------------------------
// 功能: 管理整个分支定界搜索过程
// 算法流程:
//   1. 选择待分支节点
//   2. 生成左右子节点
//   3. 对子节点执行列生成求解
//   4. 检查整数性, 更新最优解
//   5. 重复直至无可分支节点
// 参数:
//   Values - 全局参数
//   Lists  - 全局列表
// 返回值:
//   0 = 正常结束
// -----------------------------------------------------------------------------
int BranchAndPriceTree(All_Values& Values, All_Lists& Lists);

// -----------------------------------------------------------------------------
// ChooseNodeToBranch - 选择待分支节点
// -----------------------------------------------------------------------------
// 功能: 根据搜索策略选择下一个要分支的节点
// 策略:
//   - 优先选择下界较小的节点 (最优优先搜索)
//   - 剪枝 LB >= optimal_LB 的节点
// 参数:
//   Values      - 全局参数
//   Lists       - 全局列表
//   parent_node - 输出: 选中的父节点
// 返回值:
//   0 = 无可分支节点 (算法终止)
//   1 = 找到待分支节点
// -----------------------------------------------------------------------------
int ChooseNodeToBranch(All_Values& Values, All_Lists& Lists, Node& parent_node);

// -----------------------------------------------------------------------------
// GenerateNewNode - 生成新的子节点
// -----------------------------------------------------------------------------
// 功能: 基于父节点信息创建新的子节点
// 操作:
//   1. 复制父节点的模型矩阵和列集合
//   2. 设置分支变量的固定值 (floor 或 ceil)
//   3. 维护已分支变量的历史记录
// 参数:
//   Values      - 全局参数
//   Lists       - 全局列表
//   new_node    - 输出: 新生成的子节点
//   parent_node - 父节点
// -----------------------------------------------------------------------------
void GenerateNewNode(All_Values& Values, All_Lists& Lists, Node& new_node, Node& parent_node);


// =============================================================================
// 非根节点列生成函数
// =============================================================================

// -----------------------------------------------------------------------------
// NewNodeColumnGeneration - 非根节点列生成主循环
// -----------------------------------------------------------------------------
// 功能: 对分支产生的新节点执行列生成求解
// 与根节点的区别:
//   - 继承父节点的列集合
//   - 分支变量被固定为整数值
//   - 之前分支的变量保持固定
// 参数:
//   Values      - 全局参数
//   Lists       - 全局列表
//   this_node   - 当前新节点
//   parent_node - 父节点
// -----------------------------------------------------------------------------
void NewNodeColumnGeneration(All_Values& Values, All_Lists& Lists, Node& this_node, Node& parent_node);

// -----------------------------------------------------------------------------
// SolveNewNodeFirstMasterProblem - 求解非根节点初始主问题
// -----------------------------------------------------------------------------
// 功能: 构建考虑分支约束的初始主问题并求解
// 变量边界处理:
//   - 当前分支变量: 固定为 floor 或 ceil 值
//   - 已分支变量: 固定为之前确定的整数值
//   - 未分支变量: 保持 [0, +inf) 范围
// 参数:
//   Values       - 全局参数
//   Lists        - 全局列表
//   Env_MP       - CPLEX 环境对象
//   Model_MP     - CPLEX 模型对象
//   Obj_MP       - 目标函数对象
//   Cons_List_MP - 约束数组
//   Vars_List_MP - 变量数组
//   this_node    - 当前新节点
//   parent_node  - 父节点
// 返回值:
//   true  = 主问题可行
//   false = 主问题不可行 (节点需剪枝)
// -----------------------------------------------------------------------------
bool SolveNewNodeFirstMasterProblem(
    All_Values& Values,
    All_Lists& Lists,
    IloEnv& Env_MP,
    IloModel& Model_MP,
    IloObjective& Obj_MP,
    IloRangeArray& Cons_List_MP,
    IloNumVarArray& Vars_List_MP,
    Node& this_node,
    Node& parent_node);


// =============================================================================
// 输出函数
// =============================================================================

// -----------------------------------------------------------------------------
// OutputMasterProblem - 输出原始主问题矩阵
// -----------------------------------------------------------------------------
// 功能: 将当前主问题的系数矩阵输出到文本文件 (调试用)
// 输出文件: Master Problem.txt
// 输出格式:
//   y1  y2  ... x1  x2  ...
//   ---------------------------
//   [C 矩阵] | [D 矩阵]  >= 0     (条带约束)
//   ---------------------------
//   [0 矩阵] | [B 矩阵]  >= d     (子件约束)
// 参数:
//   Values    - 全局参数
//   Lists     - 全局列表
//   this_node - 当前节点
// -----------------------------------------------------------------------------
void OutputMasterProblem(All_Values& Values, All_Lists& Lists, Node& this_node);

// -----------------------------------------------------------------------------
// OutputDualMasterProblem - 输出对偶主问题矩阵
// -----------------------------------------------------------------------------
// 功能: 将当前主问题的对偶形式输出到文本文件 (调试用)
// 输出文件: Dual Master Problem.txt
// 参数:
//   Values    - 全局参数
//   Lists     - 全局列表
//   this_node - 当前节点
// -----------------------------------------------------------------------------
void OutputDualMasterProblem(All_Values& Values, All_Lists& Lists, Node& this_node);

// -----------------------------------------------------------------------------
// OutputHeuristicResults - 输出启发式求解结果
// -----------------------------------------------------------------------------
// 功能: 将启发式生成的切割方案输出到控制台和文件
// 输出文件: D:/CuttingTXT/Stock_N.txt (N = 母板索引)
// 文件格式: 坐标点列表 (用于可视化绘图)
// 参数:
//   Values - 全局参数
//   Lists  - 全局列表
// -----------------------------------------------------------------------------
void OutputHeuristicResults(All_Values& Values, All_Lists& Lists);

// -----------------------------------------------------------------------------
// OutputFinalResults - 输出最终求解结果
// -----------------------------------------------------------------------------
// 功能: 输出分支定价算法的最终求解结果
// 参数:
//   Values - 全局参数
//   Lists  - 全局列表
// -----------------------------------------------------------------------------
void OutputFinalResults(All_Values& Values, All_Lists& Lists);


#endif  // CS_2D_BP_H_
