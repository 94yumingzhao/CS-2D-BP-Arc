// =============================================================================
// new_node_column_generation.cpp - 新节点列生成
// =============================================================================
//
// 功能: 对分支定界树中新生成的节点执行列生成求解
//
// 与根节点列生成的区别:
//   1. 继承父节点的列集合 (不从头开始)
//   2. 分支变量被固定为整数值 (floor 或 ceil)
//   3. 之前已分支的变量保持其固定值
//
// 列生成流程:
//
//   ┌─────────────────────────────────────┐
//   │  初始化 CPLEX 环境                  │
//   └─────────────────┬───────────────────┘
//                     │
//                     v
//   ┌─────────────────────────────────────┐
//   │  求解初始主问题                     │
//   │  (考虑分支约束, 固定变量边界)       │
//   └─────────────────┬───────────────────┘
//                     │
//          ┌──────────┴──────────┐
//          │  初始 MP 可行?      │
//          └──────────┬──────────┘
//             No      │     Yes
//              └──────┼──────────────┐
//                     │              │
//                     v              v
//             ┌───────────┐   ┌──────────────────┐
//             │  剪枝节点 │   │  进入列生成循环  │
//             └───────────┘   └────────┬─────────┘
//                                      │
//                          ┌───────────┴───────────┐
//                          │  求解子问题           │
//                          │  (寻找 reduced cost   │
//                          │   < 0 的新列)         │
//                          └───────────┬───────────┘
//                                      │
//                          ┌───────────┴───────────┐
//                          │  找到改进列?          │
//                          └───────────┬───────────┘
//                             No       │     Yes
//                              └───────┼───────────┐
//                                      │           │
//                                      v           v
//                              ┌───────────┐  ┌────────────────┐
//                              │  收敛     │  │  添加新列      │
//                              │  求解最终 │  │  更新主问题    │──┐
//                              │  主问题   │  └────────────────┘  │
//                              └───────────┘          ^           │
//                                                     └───────────┘
//
// =============================================================================

#include "2DBP.h"

using namespace std;

// -----------------------------------------------------------------------------
// NewNodeColumnGeneration - 新节点列生成主函数
// -----------------------------------------------------------------------------
// 功能: 对新生成的子节点执行完整的列生成过程
//
// 执行步骤:
//   1. 初始化 CPLEX 环境
//   2. 求解初始主问题 (考虑分支约束)
//   3. 如果可行, 进入列生成循环
//   4. 收敛后求解最终主问题, 获取下界
//   5. 释放 CPLEX 资源
//
// 参数:
//   Values      - 全局参数
//   Lists       - 全局列表
//   this_node   - 当前新节点
//   parent_node - 父节点 (用于获取分支变量信息)
// -----------------------------------------------------------------------------
void NewNodeColumnGeneration(
	All_Values& Values,
	All_Lists& Lists,
	Node& this_node,
	Node& parent_node) {

	// =========================================================================
	// 第一步: 初始化 CPLEX 环境
	// =========================================================================
	IloEnv Env_MP;
	IloModel Model_MP(Env_MP);
	IloObjective Obj_MP = IloAdd(Model_MP, IloMinimize(Env_MP));
	IloRangeArray Cons_MP(Env_MP);
	IloNumVarArray Vars_MP(Env_MP);

	this_node.iter = 0;

	// =========================================================================
	// 第二步: 求解初始主问题
	// =========================================================================
	// 与根节点不同, 这里需要考虑:
	//   - 当前分支变量的固定值
	//   - 之前已分支变量的固定值
	// =========================================================================
	bool MP_flag = SolveNewNodeFirstMasterProblem(
		Values,
		Lists,
		Env_MP,
		Model_MP,
		Obj_MP,
		Cons_MP,
		Vars_MP,
		this_node,
		parent_node);

	// =========================================================================
	// 第三步: 列生成主循环
	// =========================================================================
	if (MP_flag == 1) {
		// ----- 初始主问题可行, 进入列生成循环 -----
		while (1) {
			this_node.iter++;

			// ----- 求解子问题 -----
			int SP_flag = SolveStageOneSubProblem(Values, Lists, this_node);

			if (SP_flag == 0) {
				// 无改进列, 列生成收敛
				break;
			}
			if (SP_flag == 1) {
				// 找到改进列, 更新主问题
				SolveUpdateMasterProblem(
					Values,
					Lists,
					Env_MP,
					Model_MP,
					Obj_MP,
					Cons_MP,
					Vars_MP,
					this_node);
			}
		}

		// ----- 求解最终主问题, 获取节点下界 -----
		SolveFinalMasterProblem(
			Values,
			Lists,
			Env_MP,
			Model_MP,
			Obj_MP,
			Cons_MP,
			Vars_MP,
			this_node);
	}
	// 如果 MP_flag = 0, 初始主问题不可行, 节点已在函数内标记为剪枝

	// =========================================================================
	// 第四步: 释放 CPLEX 资源
	// =========================================================================
	// 注意: 必须按正确顺序释放, 避免内存泄漏
	// =========================================================================
	Vars_MP.clear();
	Vars_MP.end();
	Cons_MP.clear();
	Cons_MP.end();
	Obj_MP.removeAllProperties();
	Obj_MP.end();
	Model_MP.removeAllProperties();
	Model_MP.end();
	Env_MP.removeAllProperties();
	Env_MP.end();
}
