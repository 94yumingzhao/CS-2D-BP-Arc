// =============================================================================
// logger.h - 日志系统头文件
// =============================================================================
//
// 功能: 提供双输出日志功能 (终端 + 文件同步输出)
//
// 设计目标:
//   1. 透明化日志记录: 使用 cout 即可同时输出到控制台和文件
//   2. 自动时间戳: 每行输出自动添加精确到毫秒的时间戳
//   3. RAII 机制: 对象生命周期结束时自动恢复标准输出
//
// 架构概览:
//
//   ┌─────────────────────────────────────────────────────────────────┐
//   │                        应用程序代码                             │
//   │                     cout << "message"                          │
//   └─────────────────────────────┬───────────────────────────────────┘
//                                 │
//                                 v
//   ┌─────────────────────────────────────────────────────────────────┐
//   │                      DualStreambuf                              │
//   │  ┌─────────────────────────────────────────────────────────┐   │
//   │  │  1. 检查是否需要时间戳 (行首)                           │   │
//   │  │  2. 添加时间戳 [YYYY-MM-DD HH:MM:SS.mmm]                │   │
//   │  │  3. 分发输出到两个缓冲区                                │   │
//   │  └─────────────────────────────────────────────────────────┘   │
//   └──────────────┬─────────────────────────────┬────────────────────┘
//                  │                             │
//                  v                             v
//   ┌──────────────────────────┐   ┌──────────────────────────────────┐
//   │     控制台 (stdout)      │   │     日志文件 (.log)              │
//   │   实时显示程序输出       │   │   持久化保存运行记录             │
//   └──────────────────────────┘   └──────────────────────────────────┘
//
// 使用方式:
//
//   // 方式 1: 使用 Logger 类 (推荐)
//   int main() {
//       Logger logger("output/run_log");  // 自动重定向 cout
//       cout << "[启动] 程序开始运行\n";  // 同时输出到控制台和文件
//       // ... 程序逻辑 ...
//   }  // 析构时自动恢复 cout
//
//   // 方式 2: 使用 Log 宏
//   Log("[初始化] 加载配置完成");        // 带换行
//   LogNoNL("[进度] 处理中...");          // 不带换行
//
// 输出示例:
//   [2024-01-15 14:30:25.123] [启动] 程序开始运行
//   [2024-01-15 14:30:25.456] [输入] 读取数据文件: input.txt
//   [2024-01-15 14:30:26.789] [求解] 开始列生成迭代
//
// =============================================================================

#ifndef LOGGER_H
#define LOGGER_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <memory>
#include <chrono>
#include <iomanip>
#include <ctime>

// =============================================================================
// DualStreambuf - 双输出流缓冲区
// =============================================================================
//
// 功能: 继承 std::streambuf, 实现输出到两个目标的流缓冲区
//
// 实现原理:
//   - 重写 overflow(): 处理单字符输出
//   - 重写 xsputn():   处理批量字符输出
//   - 维护时间戳状态: 在每行开头自动添加时间戳
//
// =============================================================================
class DualStreambuf : public std::streambuf {
public:
	// -------------------------------------------------------------------------
	// 构造函数
	// -------------------------------------------------------------------------
	// 参数:
	//   console_buf - 控制台输出缓冲区 (通常是 cout.rdbuf())
	//   file_buf    - 文件输出缓冲区 (日志文件的 rdbuf())
	// -------------------------------------------------------------------------
	DualStreambuf(std::streambuf* console_buf, std::streambuf* file_buf);

	// -------------------------------------------------------------------------
	// 禁用复制和移动 (流缓冲区不应被复制)
	// -------------------------------------------------------------------------
	DualStreambuf(const DualStreambuf&) = delete;
	DualStreambuf& operator=(const DualStreambuf&) = delete;
	DualStreambuf(DualStreambuf&&) = delete;
	DualStreambuf& operator=(DualStreambuf&&) = delete;

protected:
	// -------------------------------------------------------------------------
	// overflow - 单字符输出处理 (虚函数重写)
	// -------------------------------------------------------------------------
	// 功能: 当缓冲区满或遇到特殊字符时调用
	// 参数: c - 要输出的字符
	// 返回: 成功返回字符值, 失败返回 EOF
	// -------------------------------------------------------------------------
	int overflow(int c) override;

	// -------------------------------------------------------------------------
	// xsputn - 批量字符输出处理 (虚函数重写)
	// -------------------------------------------------------------------------
	// 功能: 输出字符串时调用, 提高批量输出效率
	// 参数:
	//   s     - 字符串指针
	//   count - 字符数量
	// 返回: 实际写入的字符数
	// -------------------------------------------------------------------------
	std::streamsize xsputn(const char* s, std::streamsize count) override;

private:
	std::streambuf* console_buf_;   // 控制台缓冲区指针
	std::streambuf* file_buf_;      // 文件缓冲区指针
	bool need_timestamp_;           // 标记: 下一个字符是否需要时间戳

	// -------------------------------------------------------------------------
	// getCurrentTimestamp - 获取当前时间戳
	// -------------------------------------------------------------------------
	// 返回格式: "[YYYY-MM-DD HH:MM:SS.mmm] "
	// -------------------------------------------------------------------------
	std::string getCurrentTimestamp();

	// -------------------------------------------------------------------------
	// writeTimestamp - 向两个缓冲区写入时间戳
	// -------------------------------------------------------------------------
	void writeTimestamp();
};

// =============================================================================
// Logger - 日志管理器
// =============================================================================
//
// 功能: 管理日志文件的创建、cout 重定向和资源清理
//
// 生命周期:
//   1. 构造: 创建日志文件, 保存原始 cout 缓冲区, 重定向到双缓冲区
//   2. 运行: 所有 cout 输出自动写入控制台和文件
//   3. 析构: 恢复原始 cout 缓冲区, 关闭日志文件
//
// =============================================================================
class Logger {
public:
	// -------------------------------------------------------------------------
	// 构造函数 - 初始化日志系统
	// -------------------------------------------------------------------------
	// 参数: log_prefix - 日志文件前缀 (自动添加 .log 扩展名)
	// 示例: Logger("output/run") -> 创建 output/run.log
	// -------------------------------------------------------------------------
	explicit Logger(const std::string& log_prefix);

	// -------------------------------------------------------------------------
	// 析构函数 - 恢复标准输出并关闭日志文件
	// -------------------------------------------------------------------------
	~Logger();

	// -------------------------------------------------------------------------
	// 禁用复制和移动 (日志管理器不应被复制)
	// -------------------------------------------------------------------------
	Logger(const Logger&) = delete;
	Logger& operator=(const Logger&) = delete;
	Logger(Logger&&) = delete;
	Logger& operator=(Logger&&) = delete;

	// -------------------------------------------------------------------------
	// getLogFilePath - 获取日志文件路径
	// -------------------------------------------------------------------------
	std::string getLogFilePath() const { return log_file_path_; }

private:
	std::ofstream log_file_;                    // 日志文件输出流
	std::streambuf* old_cout_buf_;              // 原始 cout 缓冲区 (用于恢复)
	std::unique_ptr<DualStreambuf> dual_buf_;   // 双输出缓冲区
	std::string log_file_path_;                 // 日志文件完整路径
};

// =============================================================================
// 辅助函数
// =============================================================================

// -----------------------------------------------------------------------------
// GetCurrentTimestamp - 获取当前时间戳字符串 (用于文件名)
// -----------------------------------------------------------------------------
// 返回格式: YYYYMMDD_HHMMSS_mmm
// 用途: 生成唯一的日志文件名
// 示例: "20240115_143025_123"
// -----------------------------------------------------------------------------
inline std::string GetCurrentTimestamp() {
	auto now = std::chrono::system_clock::now();
	auto time_t = std::chrono::system_clock::to_time_t(now);
	auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
		now.time_since_epoch()) % 1000;

	std::stringstream ss;
	ss << std::put_time(std::localtime(&time_t), "%Y%m%d_%H%M%S")
	   << "_" << std::setfill('0') << std::setw(3) << ms.count();
	return ss.str();
}

// =============================================================================
// 日志输出宏
// =============================================================================
// 提供便捷的日志输出接口, 可直接使用而无需访问 cout
// =============================================================================

// Log - 带换行的日志输出
// 用法: Log("[模块] 消息内容");
#define Log(msg) std::cout << msg << std::endl

// LogNoNL - 不带换行的日志输出 (用于进度显示等)
// 用法: LogNoNL("[进度] 50%...");
#define LogNoNL(msg) std::cout << msg

// LogFmt - 格式化日志输出 (支持 printf 风格)
// 用法: LogFmt("[统计] 处理了 %d 个文件, 耗时 %.2f 秒", count, time);
#define LogFmt(fmt, ...) do { \
	char _log_buf[1024]; \
	snprintf(_log_buf, sizeof(_log_buf), fmt, ##__VA_ARGS__); \
	std::cout << _log_buf; \
} while(0)

#endif // LOGGER_H
